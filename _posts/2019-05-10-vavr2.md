---
layout: post
title: Vavr入门（2）
# subtitle: '或许是最漂亮的Jekyll主题'
date: 2019-06-10
categories: [dev]
tags: [java, vavr]
---
[前一篇文章](../vavr/)介绍了元组和函数式增强，似乎感觉vavr有点鸡肋。希望这篇文章能稍微改善一点你的看法。

本文里的类都是线程安全的。

## Option
这个类看起来像是Java的Optional的重新实现，当然用法不一样。它的返回总是Some或None。
```
// optional *value*, no more nulls
Option<T> option = Option.of(...);
```

使用原生Optional下面的代码运行正常：
```
Optional<String> maybeFoo = Optional.of("foo"); 
then(maybeFoo.get()).isEqualTo("foo");
Optional<String> maybeFooBar = maybeFoo.map(s -> (String)null)  
                                       .map(s -> s.toUpperCase() + "bar");
then(maybeFooBar.isPresent()).isFalse();
```
而使用Vavr的Option，类似的写法会导致NullPointerException：
```
Option<String> maybeFoo = Option.of("foo"); 
then(maybeFoo.get()).isEqualTo("foo");
try {
    maybeFoo.map(s -> (String)null) 
            .map(s -> s.toUpperCase() + "bar"); 
    Assert.fail();
} catch (NullPointerException e) {
    // this is clearly not the correct approach
}
```
这应该是他们之间最大的区别了！

> 为什么Vavr非要搞出来个空指针呢？这不是违反了它自己的理念吗？
> 
> 其实Vavr觉得Java自己的Optional才有问题呢！
> 
> Vavr认为函数式编程的上下文环境应该是类型不变的：给Some调用map方法返回是Some，所以给None调用map当然返回None了。但是Optional是将非空值映射后得到了空值。
> 
> 初看起来Option把事情搞得更糟了。但是vavr的目的就是强迫你留意可能会出现null的情况，并相应做出处理，而不是默默的接受。更详细的解释参考《[Vavr博客](http://blog.vavr.io/the-agonizing-death-of-an-astronaut/)》
> 
> 那该怎么处理null呢？

正确处理null的方法是使用flatMap：
```
Option<String> maybeFoo = Option.of("foo"); 
then(maybeFoo.get()).isEqualTo("foo");
Option<String> maybeFooBar = maybeFoo.map(s -> (String)null) 
                                     .flatMap(s -> Option.of(s) 
                                                         .map(t -> t.toUpperCase() + "bar"));
then(maybeFooBar.isEmpty()).isTrue();
``` 
或者
```
Option<String> maybeFoo = Option.of("foo"); 
then(maybeFoo.get()).isEqualTo("foo");
Option<String> maybeFooBar = maybeFoo.flatMap(s -> Option.of((String)null)) 
                                     .map(s -> s.toUpperCase() + "bar");
then(maybeFooBar.isEmpty()).isTrue();
```

## Try
如果计算可能导致异常可以使用Try。它和Either有点像，但是语义不同。Try的实例要么是Success，要么是Failure：
```
// 无需处理异常
Try.of(() -> bunchOfWork()).getOrElse(other);
```
```
import static io.vavr.API.*;        // $, Case, Match
import static io.vavr.Predicates.*; // instanceOf

A result = Try.of(this::bunchOfWork)
    .recover(x -> Match(x).of(
        Case($(instanceOf(Exception_1.class)), t -> somethingWithException(t)),
        Case($(instanceOf(Exception_2.class)), t -> somethingWithException(t)),
        Case($(instanceOf(Exception_n.class)), t -> somethingWithException(t))
    ))
    .getOrElse(other);
```
## Lazy
Lazy是封装延迟计算值的容器。与Supplier不同的是，Lazy是记忆函数，只会计算一次：
```
Lazy<Double> lazy = Lazy.of(Math::random);
lazy.isEvaluated(); // = false
lazy.get();         // = 0.123 
lazy.isEvaluated(); // = true
lazy.get();         // = 0.123
```

## Either
Either represents a value of two possible types. An Either is either a Left or a Right. If the given Either is a Right and projected to a Left, the Left operations have no effect on the Right value. If the given Either is a Left and projected to a Right, the Right operations have no effect on the Left value. If a Left is projected to a Left or a Right is projected to a Right, the operations have an effect.

Example: A compute() function, which results either in an Integer value (in the case of success) or in an error message of type String (in the case of failure). By convention the success case is Right and the failure is Left.

Either<String,Integer> value = compute().right().map(i -> i * 2).toEither();
If the result of compute() is Right(1), the value is Right(2).
If the result of compute() is Left("error"), the value is Left("error").

3.3.5. Future
A Future is a computation result that becomes available at some point. All operations provided are non-blocking. The underlying ExecutorService is used to execute asynchronous handlers, e.g. via onComplete(…​).

A Future has two states: pending and completed.

Pending: The computation is ongoing. Only a pending future may be completed or cancelled.

Completed: The computation finished successfully with a result, failed with an exception or was cancelled.

Callbacks may be registered on a Future at each point of time. These actions are performed as soon as the Future is completed. An action which is registered on a completed Future is immediately performed. The action may run on a separate Thread, depending on the underlying ExecutorService. Actions which are registered on a cancelled Future are performed with the failed result.

// future *value*, result of an async calculation
Future<T> future = Future.of(...);
3.3.6. Validation
The Validation control is an applicative functor and facilitates accumulating errors. When trying to compose Monads, the combination process will short circuit at the first encountered error. But 'Validation' will continue processing the combining functions, accumulating all errors. This is especially useful when doing validation of multiple fields, say a web form, and you want to know all errors encountered, instead of one at a time.

Example: We get the fields 'name' and 'age' from a web form and want to create either a valid Person instance, or return the list of validation errors.

PersonValidator personValidator = new PersonValidator();

// Valid(Person(John Doe, 30))
Validation<Seq<String>, Person> valid = personValidator.validatePerson("John Doe", 30);

// Invalid(List(Name contains invalid characters: '!4?', Age must be greater than 0))
Validation<Seq<String>, Person> invalid = personValidator.validatePerson("John? Doe!4", -1);
A valid value is contained in a Validation.Valid instance, a list of validation errors is contained in a Validation.Invalid instance.

The following validator is used to combine different validation results to one Validation instance.

class PersonValidator {

    private static final String VALID_NAME_CHARS = "[a-zA-Z ]";
    private static final int MIN_AGE = 0;

    public Validation<Seq<String>, Person> validatePerson(String name, int age) {
        return Validation.combine(validateName(name), validateAge(age)).ap(Person::new);
    }

    private Validation<String, String> validateName(String name) {
        return CharSeq.of(name).replaceAll(VALID_NAME_CHARS, "").transform(seq -> seq.isEmpty()
                ? Validation.valid(name)
                : Validation.invalid("Name contains invalid characters: '"
                + seq.distinct().sorted() + "'"));
    }

    private Validation<String, Integer> validateAge(int age) {
        return age < MIN_AGE
                ? Validation.invalid("Age must be at least " + MIN_AGE)
                : Validation.valid(age);
    }

}
If the validation succeeds, i.e. the input data is valid, then an instance of Person is created of the given fields name and age.

class Person {

    public final String name;
    public final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person(" + name + ", " + age + ")";
    }

}
3.4. Collections
Much effort has been put into designing an all-new collection library for Java which meets the requirements of functional programming, namely immutability.

Java’s Stream lifts a computation to a different layer and links to a specific collection in another explicit step. With Vavr we don’t need all this additional boilerplate.

The new collections are based on java.lang.Iterable, so they leverage the sugared iteration style.

// 1000 random numbers
for (double random : Stream.continually(Math::random).take(1000)) {
    ...
}
TraversableOnce has a huge amount of useful functions to operate on the collection. Its API is similar to java.util.stream.Stream but more mature.

3.4.1. List
Vavr’s List is an immutable linked list. Mutations create new instances. Most operations are performed in linear time. Consequent operations are executed one by one.

Java 8
Arrays.asList(1, 2, 3).stream().reduce((i, j) -> i + j);
IntStream.of(1, 2, 3).sum();
Vavr
// io.vavr.collection.List
List.of(1, 2, 3).sum();
3.4.2. Stream
The io.vavr.collection.Stream implementation is a lazy linked list. Values are computed only when needed. Because of its laziness, most operations are performed in constant time. Operations are intermediate in general and executed in a single pass.

The stunning thing about streams is that we can use them to represent sequences that are (theoretically) infinitely long.

// 2, 4, 6, ...
Stream.from(1).filter(i -> i % 2 == 0);
3.4.3. Performance Characteristics
Table 1. Time Complexity of Sequential Operations
head()	tail()	get(int)	update(int, T)	prepend(T)	append(T)
Array

const

linear

const

const

linear

linear

CharSeq

const

linear

const

linear

linear

linear

Iterator

const

const

—

—

—

—

List

const

const

linear

linear

const

linear

Queue

const

consta

linear

linear

const

const

PriorityQueue

log

log

—

—

log

log

Stream

const

const

linear

linear

constlazy

constlazy

Vector

consteff

consteff

const eff

const eff

const eff

const eff

Table 2. Time Complexity of Map/Set Operations
contains/Key	add/put	remove	min
HashMap

 consteff

consteff

consteff

linear

HashSet

consteff

consteff

consteff

linear

LinkedHashMap

consteff

linear

linear

linear

LinkedHashSet

consteff

linear

linear

linear

Tree

log

log

log

log

TreeMap

 log

log

log

log

TreeSet

 log

log

log

log

Legend:

const — constant time

consta — amortized constant time, few operations may take longer

consteff — effectively constant time, depending on assumptions like distribution of hash keys

constlazy — lazy constant time, the operation is deferred

log — logarithmic time

linear — linear time

3.5. Property Checking
Property checking (also known as property testing) is a truly powerful way to test properties of our code in a functional way. It is based on generated random data, which is passed to a user defined check function.

Vavr has property testing support in its io.vavr:vavr-test module, so make sure to include that in order to use it in your tests.

Arbitrary<Integer> ints = Arbitrary.integer();

// square(int) >= 0: OK, passed 1000 tests.
Property.def("square(int) >= 0")
        .forAll(ints)
        .suchThat(i -> i * i >= 0)
        .check()
        .assertIsSatisfied();
Generators of complex data structures are composed of simple generators.

3.6. Pattern Matching
Scala has native pattern matching, one of the advantages over plain Java. The basic syntax is close to Java’s switch:

val s = i match {
  case 1 => "one"
  case 2 => "two"
  case _ => "?"
}
Notably match is an expression, it yields a result. Furthermore it offers

named parameters case i: Int ⇒ "Int " + i

object deconstruction case Some(i) ⇒ i

guards case Some(i) if i > 0 ⇒ "positive " + i

multiple conditions case "-h" | "--help" ⇒ displayHelp

compile-time checks for exhaustiveness

Pattern matching is a great feature that saves us from writing stacks of if-then-else branches. It reduces the amount of code while focusing on the relevant parts.

3.6.1. The Basics of Match for Java
Vavr provides a match API that is close to Scala’s match. It is enabled by adding the following import to our application:

import static io.vavr.API.*;
Having the static methods Match, Case and the atomic patterns

$() - wildcard pattern

$(value) - equals pattern

$(predicate) - conditional pattern

in scope, the initial Scala example can be expressed like this:

String s = Match(i).of(
    Case($(1), "one"),
    Case($(2), "two"),
    Case($(), "?")
);
⚡ We use uniform upper-case method names because 'case' is a keyword in Java. This makes the API special.

Exhaustiveness
The last wildcard pattern $() saves us from a MatchError which is thrown if no case matches.

Because we can’t perform exhaustiveness checks like the Scala compiler, we provide the possibility to return an optional result:

Option<String> s = Match(i).option(
    Case($(0), "zero")
);
Syntactic Sugar
As already shown, Case allows to match conditional patterns.

Case($(predicate), ...)
Vavr offers a set of default predicates.

import static io.vavr.Predicates.*;
These can be used to express the initial Scala example as follows:

String s = Match(i).of(
    Case($(is(1)), "one"),
    Case($(is(2)), "two"),
    Case($(), "?")
);
Multiple Conditions

We use the isIn predicate to check multiple conditions:

Case($(isIn("-h", "--help")), ...)
Performing Side-Effects

Match acts like an expression, it results in a value. In order to perform side-effects we need to use the helper function run which returns Void:

Match(arg).of(
    Case($(isIn("-h", "--help")), o -> run(this::displayHelp)),
    Case($(isIn("-v", "--version")), o -> run(this::displayVersion)),
    Case($(), o -> run(() -> {
        throw new IllegalArgumentException(arg);
    }))
);
⚡ run is used to get around ambiguities and because void isn’t a valid return value in Java.

Caution: run must not be used as direct return value, i.e. outside of a lambda body:

// Wrong!
Case($(isIn("-h", "--help")), run(this::displayHelp))
Otherwise the Cases will be eagerly evaluated before the patterns are matched, which breaks the whole Match expression. Instead we use it within a lambda body:

// Ok
Case($(isIn("-h", "--help")), o -> run(this::displayHelp))
As we can see, run is error prone if not used right. Be careful. We consider deprecating it in a future release and maybe we will also provide a better API for performing side-effects.

Named Parameters
Vavr leverages lambdas to provide named parameters for matched values.

Number plusOne = Match(obj).of(
    Case($(instanceOf(Integer.class)), i -> i + 1),
    Case($(instanceOf(Double.class)), d -> d + 1),
    Case($(), o -> { throw new NumberFormatException(); })
);
So far we directly matched values using atomic patterns. If an atomic pattern matches, the right type of the matched object is inferred from the context of the pattern.

Next, we will take a look at recursive patterns that are able to match object graphs of (theoretically) arbitrary depth.

Object Decomposition
In Java we use constructors to instantiate classes. We understand object decomposition as destruction of objects into their parts.

While a constructor is a function which is applied to arguments and returns a new instance, a deconstructor is a function which takes an instance and returns the parts. We say an object is unapplied.

Object destruction is not necessarily a unique operation. For example, a LocalDate can be decomposed to

the year, month and day components

the long value representing the epoch milliseconds of the corresponding Instant

etc.

3.6.2. Patterns
In Vavr we use patterns to define how an instance of a specific type is deconstructed. These patterns can be used in conjunction with the Match API.

Predefined Patterns
For many Vavr types there already exist match patterns. They are imported via

import static io.vavr.Patterns.*;
For example we are now able to match the result of a Try:

Match(_try).of(
    Case($Success($()), value -> ...),
    Case($Failure($()), x -> ...)
);
⚡ A first prototype of Vavr’s Match API allowed to extract a user-defined selection of objects from a match pattern. Without proper compiler support this isn’t practicable because the number of generated methods exploded exponentially. The current API makes the compromise that all patterns are matched but only the root patterns are decomposed.

Match(_try).of(
    Case($Success(Tuple2($("a"), $())), tuple2 -> ...),
    Case($Failure($(instanceOf(Error.class))), error -> ...)
);
Here the root patterns are Success and Failure. They are decomposed to Tuple2 and Error, having the correct generic types.

⚡ Deeply nested types are inferred according to the Match argument and not according to the matched patterns.

User-Defined Patterns
It is essential to be able to unapply arbitrary objects, including instances of final classes. Vavr does this in a declarative style by providing the compile time annotations @Patterns and @Unapply.

To enable the annotation processor the artifact vavr-match needs to be added as project dependency.

⚡ Note: Of course the patterns can be implemented directly without using the code generator. For more information take a look at the generated source.

import io.vavr.match.annotation.*;

@Patterns
class My {

    @Unapply
    static <T> Tuple1<T> Optional(java.util.Optional<T> optional) {
        return Tuple.of(optional.orElse(null));
    }
}
The annotation processor places a file MyPatterns in the same package (by default in target/generated-sources). Inner classes are also supported. Special case: if the class name is $, the generated class name is just Patterns, without prefix.

Guards
Now we are able to match Optionals using guards.

Match(optional).of(
    Case($Optional($(v -> v != null)), "defined"),
    Case($Optional($(v -> v == null)), "empty")
);
The predicates could be simplified by implementing isNull and isNotNull.

⚡ And yes, extracting null is weird. Instead of using Java’s Optional give Vavr’s Option a try!

Match(option).of(
    Case($Some($()), "defined"),
    Case($None(), "empty")
);