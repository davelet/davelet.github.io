---
layout: post
title: 领域驱动设计DDD入门5：战术工具之聚合
categories: [dev]
tags: [ddd]
---
第五节课我们讲一个战术工具：聚合。

 An aggregate is a tactical modeling tool that helps you design small and efficient object clusters that manage consistency constraints using transactions. First, I explain why aggregates are used. Next, I introduce the four aggregate design rules of thumb. This is followed by techniques to use with modeling aggregates. We next consider why you should choose carefully your level of abstraction when modeling aggregates. Since it's a goal to keep aggregates small, I show you techniques for right-sizing aggregates. Finally, we consider how to ensure that aggregates are designed as testable units.

- So far we've been discussing strategic design with bounded contexts, sub-domains and context mapping. And here you see two bounded contexts, the core domain, the agile project management context, and a supporting sub-domain, the collaboration context. But what about the objects that live inside, the concepts that make up the actual domain model? Well that's what we're going to be looking at next. These are likely the aggregates that live in your model.

- As you can see from this diagram, there are several concepts that live inside each bounded context. The Product, the BacklogItem, the Release, and Sprint in the agile project management context and the Forum, Discussion, Post, and the Calendar and CalendarEntry. What are these? These are the aggregates. Notice that there's also one concept there, Dicussion that is not considered an aggregate. It's an individual value object. We won't be focusing on value objects, but we are going to take a deep dive into aggregates and why they're used. An aggregate has a few different parts to it. An aggregate has a root entity called the aggregate root. An aggregate root entity may also hold other entities and value objects. Inside the aggregate as a whole we consider this to be a transaction boundary. Here you two separate aggregates where the aggregate root entity names the aggregate concept as a whole. So let's focus on the aggregate root here. Again, this is an entity that names the concept of the entire aggregate and it has global unique identity, so that this aggregate is globally unique from all other entities or aggregates of the same type or of different types. An aggregate is a transactional consistency boundary. Inside an aggregate, everything must be consistent at the end of a transaction. So at the beginning of a use case operation, you start a transaction and then dispatch to the aggregate. The transaction is in play, the aggregate makes its changes according to the operation being performed on it and then it finishes. After that, the transaction commits. It's expected that following the transaction, everything within a single aggregate boundary is consistent and up to date. Thus, in Aggregate Type 1, as you see here, there is a single transaction at play. Notice that the transaction does not have a scope around Aggregate Type 2. In a separate transaction, Aggregate Type 2 will be updated. Notice that things that are in Aggregate Type 1 will not be updated in the same transaction. So it's easy to think of an aggregate as being a transactional boundary. Again, this causes everything within the scope of a single aggregate instance to be up to date and consistent within a single transaction. So there's a single transaction that controls the state of Aggregate Type 1 and there is a separate transaction that controls the state of Aggregate Type 2.

- We're now going to look at the four rules of aggregate design. We call these the Rules of Thumb of Aggregate Design. The first rule is protect business invariants inside aggregate boundaries. As an example, aggregates of type one and aggregates of type two that we were previously looking at, followed this rule of thumb. The second rule is design small aggregates. The third rule is reference other aggregates by identity only. The fourth rule is update other aggregates using eventual consistency. Now, when you reason about all four of these rules, you could probably imagine how they work. And you saw examples of those rules being used in the previous aggregate of type one and aggregate of type two. Let's take a closer look at the first rule, protect business invariants. So, here we have an example of a product aggregate and our sprint aggregate. Each of these are controlled under a separate transaction. As you can see, the product aggregate has a root entity named product. The product holds a reference to product ID and also has a reference to product backlog item. And this is a one to many relationship. So, for each product root entity, there may be many product backlog items. Looking at the sprint aggregate, we have a sprint root entity and the sprint holds a sprint ID which is a value object, and it holds a set of entities committed backlog item. Again, the relationship oo association between sprint and committed backlog item is a one to many relationship. So, there may be many committed backlog items within the sprint. The product aggregate and the sprint aggregate are each controlled under separate transactions. So, their business invariants are being protected individually as single instances of aggregates. Notice that the backlog item aggregate in this example has a root entity backlog item. It holds a backlog item ID value object and it has a one to many relationship to tasks. In other words, there may be many tasks under a single backlog item. Notice that the backlog item has a status. The status will be set to planned, committed and done under different situations. Also notice that each task has an hours remaining that may be set to the number of hours, one, two, three, four, five and so forth, or to zero. When all tasks under a single backlog item have transitioned to zero hours remaining, then the status of the backlog item must be set to done. Therefore, when all other tasks have hours remaining of zero except for one task, which has some number of hours remaining, the status of the backlog item will still be set to committed. But when that one remaining task has it's hours remaining set to zero, in the same transaction we must transition the status of the backlog item to done. This is a business constraint that is required to be consistent at all times, and therefore must be controlled under a single transaction. At the beginning of the transaction, status will still be set to committed, one of the tasks will have some hours remaining. At the end of the transaction when the hours remaining under that task are set to zero, the status of the backlog item will be transitioned to done and that entire transaction will be committed with those states in tact. That's protecting business invariants, the first rule of thumb. The second rule of thumb, of aggregate design is to design small aggregates. As you can see here, it's possible to design the product aggregate to hold all of its backlog items, all of its releases, and all of its sprints. But this is a large aggregate, and we want to focus on designing small aggregates. One of the problems that is faced is that this large aggregate design will likely cause transactional failures because of separate users with different goals modifying the same aggregate in separate transactions. For example, if we commit a backlog item to a sprint and we plan a new backlog item, this will change different parts of the same aggregate instance at the same time, causing failure. Or, if we schedule a new release and plan a new backlog item at the same time, again, different parts of this large cluster product aggregate will be modified at the same time by two different users, causing transactional failure. Because, one of the transactions will win and the other transaction will fail because of a concurrency violation in the database. So, you can see that there is at least one big disadvantage to designing large aggregates. Some other disadvantages are the size of the aggregate in memory at any given time takes up a lot of memory. It's also slower to load and causes garbage collection problems potentially. So, there are several reasons to design small aggregates. Let's look at the product aggregate as we've broken it up and we have now four separate aggregates. The product aggregate no longer holds backlog items, releases in sprints. Instead, what we've done is design backlog item release in sprint aggregate types. So, there are four different aggregate types. Now, this is a much better design. It prevents concurrency failures, it prevents large memory footprints of an aggregate and allows each aggregate to take up only the memory needed, garbage collection is vastly improved and so, overall, we've improved our modeling situation tremendously. The third rule of aggregate design is to reference by identity only. Here you can see the four aggregates that we now have the product aggregate, the backlog item aggregate, the release aggregate and the sprint aggregate. Each of these child aggregates, backlog item release and sprint need to know their parent, the product aggregate. So, we can say that each of the three child aggregates are owned by their parent. But how do they know about the parent? Notice that we do not hold a reference to the product parent aggregate directly in any of the children. Instead, the children simply reference their parent by product ID. This has several advantages. One of the advantages is that, again, there is a smaller footprint when loading the child aggregates into memory. On the other hand, there's another big advantage in that we cannot reach out to the parent aggregate directly and make a modification to it at the same time that one of the child aggregates is being modified. Therefore, we're not tempted to break the first rule of aggregate design by putting constraints around a single aggregate and managing a single transaction on a single instance of the aggregate. This will make our aggregates perform much better and will be less susceptible to failures in transactions. The fourth rule of aggregate design is to update other aggregates eventually. Or in other words, use eventual consistency. As you can see, when a backlog item is committed to a sprint, it's going to hold the identity of the sprint to which it is now committed. When the backlog item is committed to a sprint and the sprint ID is set on it, that backlog item is going to be committed in a single transaction. The sprint aggregate does not yet know that the backlog item has been committed to it. Eventually, the sprint aggregate will learn that a new backlog item has been committed to it, and it will now hold a committed backlog item instance, entity under the sprint root, this entity will be set in a separate transaction. How does this happen? Notice that when the backlog item is committed to the sprint, the backlog item publishes a backlog item committed domain event. This domain event is eventually reacted to by our agile project management context and the agile project management context sees to it that this backlog item committed domain event has an eventual impact on the sprint aggregate. In the end, the sprint aggregate has a new committed backlog item added to it and that committed backlog item has a reference to the backlog item that is committed to it through the backlog item ID. So, here you can see that eventual consistency has two different aggregate instances being updated in separate transactions. How does this work? The publishing bounded context, the aggregate within publishes a domain event which is eventually received by a messaging mechanism. The messaging mechanism then publishes this domain event to interested parties. The subscribing bounded context then receives the domain event notification and reacts to it and likely an aggregate in the subscribing bounded context is updated. It's just that in the case of the agile project management context, with the backlog item committed operation, when the backlog item publishes the backlog item committed domain event, the messaging mechanism notifies the agile project management context which is a subscriber to its own domain events and the sprint within that agile project management context receives the impact or reacts to the fact that this domain event has been received and the sprint is eventually updated and committed under a separate transaction.

- How do we model aggregates? Well, there are several pieces of guidance that I'd like to share with you now, but I also want to give you a warning. Watch out for the hooks. Don't take the bait when you're tempted to model with the anemic domain model. An anemic domain model is generally void of behavior. You'll probably find a lot of getters and setters on an anemic domain model. This leads to all of the overhead of a domain model without gaining any of the benefits, so as we go through this modeling material, I'm going to steer you away where appropriate from using anemic domain model. How do you model an aggregate appropriately? First of all remember that an aggregate is a transactional consistency boundary. The entire aggregate of aggregate type one is represented here in this diagram. This aggregate has an aggregate root entity. At a minimum, you will always have a root entity for your aggregates. An aggregate root entity may also hold other parts. For example, it may hold a reference to other entities or just one entity. It may hold a reference to value objects or just one value object. At a minimum though, you will always have root entity, and the root entity is named in such a way that it represents the entire aggregate concept. Here you have a root entity for the product aggregate. This entity is named product. In C# code, you can see that this is a simple class, a public class product which extends an entity base type. This entity may be a layer supertype. In fact, you don't even need to inherit from entity. You don't need a layer supertype to create or design a worthy product aggregate. I'm just using this to show you that you can use an entity layer supertype if it helps you. What about the internal parts? Well, the product root entity will hold a tenantId and a productId. The tenantId allows for different tenants to subscribe to this service, and each tenant has a unique identity, therefore, the product class will hold two different value objects, a productId, and a tenantId. Notice too, that product has some other properties or fields. The product needs a name and a description. The name and description are simple strings, and are also held inside the aggregate root entity. What about the property accessors. In C#, notice that I have a description and a name property. Also notice that each of those has a public get accessor, but a private set accessor. Why is it that I'm using a private setter, but a public getter? This is important. This is where you can fall into anemic domain model if you're not careful. An anemic domain model has mostly public getters and public setters where you can simply modify the data inside the root entity or any other entity without actually using any behavior. Therefore, you actually want to purposely create a private setter, and this will cause you to design behavior inside the product root entity. Because you're designing behavior inside the product root entity, the behavior can call the private setter, or any of the private setters, whether it's on name or description, or any other property, but it's only the behavior that is public, and therefore, forces consumers or clients to use the public behavior. This will help you to fight against, or oppose the anemic domain model, and here's a look at some public behavior. Notice that the product root entity has a planned backlog item behavior. This behavior is designed according to the ubiquitous language of the agile project management context. According to the behavior that the product needs. Notice in UML in the diagram portion of this slide, that there is a planned product backlog item behavior, and this behavior is implemented in the C# class as a public void planned product backlog item method. Thus, as you're designing and modeling your aggregates, all of your aggregates will be modeled according to the ubiquitous language. This is extremely important when following the DDD approach. As programmers, we don't just make up the names of the methods or the aggregate roots, or any of the parts of an aggregate. We are always following the contours of the ubiquitous language as we do so, as we model. This will help us to meet the needs of the business, and design effective aggregates.

- As we model our ubiquitous language within our bounded context, remember to choose abstractions wisely. Here we're going to look at our Core Domain, the Scrum Project Management Application or service, and its natural ubiquitous language. The ubiquitous language that is spoken by the domain experts is naturally using concepts such as Product, BacklogItem, Release, and Sprint. These are the natural language elements or concepts within Scrum. They fit, and therefore the agile project management context model should be designed with these concepts in mind. However, it's also possible to take a completely different direction when modeling for a ubiquitous language. What if the developers on the project decided to try to overly abstract the model? They would actually, most likely, be ignoring the natural ubiquitous language spoken by a domain expert, and perhaps they would instead of modeling Product, BacklogItem, Release and Sprint, decide to use something like a ScrumElement. You can imagine that a Scrum Element could be used to model a Product and a BacklogItem. The ScrumElement would no doubt have a type name, field, or property, and that type name, field, or property would be set to the string, Product, when we're representing a product in the ScrumElement, and BacklogItem when we're representing a BacklogItem in the ScrumElement. But what about Release and Sprint? How would they be modeled? Well, the ScrumElementContainer might be a worthy use. The ScrumElementContainer would contain ScrumElements, and the ScrumElementContainer would have a type name that would be set to the string release when a release is being represented, and would be set to Sprint when a sprint is being represented. But, do you notice, the pitfall that we're facing here? We are moving against the tide of the ubiquitous language that is naturally spoken in Scrum. ScrumElement, and ScrumElementContainer do not properly represent the actual concrete types that naturally live within Scrum. So let's consider some of the problems that you will face if you use wrong abstractions in your model design. First and foremost, you ignore the natural ubiquitous language. Second, it's hard to model the details of specific types. For example, the ScrumElement doesn't fully represent a product or a BacklogItem. It represents something far more general. There are also going to be special cases for complex and the a-complex class hierarchy. The special cases will no doubt occur because of the differences between products and BacklogItems, and as much as we would like to think that we can create a general purpose type of ScrumElement for Product and for BacklogItem to represent both of those, it's just going to fail, because of the special cases in each of those different types. There will likely be more code than necessary, than if you were modeling explicitly. General purpose concepts require much more code than concrete's concepts. The wrong abstractions will also influence the user interface. The user interface will not follow the basic shape of the domain model that is the natural types of the ubiquitous language. Rather, it will tend to follow the shapes of the highly abstract types. This will also likely impact the user negatively. You'll waste a lot of time, and a lot of money pursuing the wrong design. It just will not work in the long run. And you'll spend a lot of time trying to maintain and work around the special cases. The imagined future proofing that you're attempting to design into the model will definitely meet with failure, because the future concepts that you imagined, that you can defensively code for today, will not be realized as you imagined them. In order to avoid all of the problems that you would face with an overly abstract model, model explicitly per the natural ubiquitous language. In doing so, you will adhere to the mental model of domain experts. This will create an understandable model. A model that can actually be understood by domain experts, because it does adhere to their mental model. It protects the organization's software investment, which then naturally leads to a saving of time and money.

- How do we right-size aggregates? Here we have aggregate type one, again. Aggregate type one has an aggregate root entity. It also holds an entity part, and it holds a value object part, is this the right size for aggregate type one? How do we know? Should aggregate type one hold the entity and hold the value object? Is there some sort of guidance that will help us to understand how to model this aggregate effectively? There is. And I'm gonna go through those steps now. These are some modeling steps that can help you to understand if you have right-sized your aggregate. The first step is to start with the rule of thumb number two, design small aggregates. So, as a first step, what you actually want to do, is design all of your aggregates with just one entity, where possible. Unless you absolutely know that a specific entity is needed. So, in this previous example of aggregate type one, you would actually break up aggregate type one to have a root entity and to make the entity that it was holding a separate aggregate. Just as a first step. The next step is to then apply rule one, protect business invariants inside consistency boundaries. Make a chart, this chart will have the names of all aggregate types in a list and the list will also have the dependents for each of those aggregates. In other words, the other aggregates that will updated in some time frame, according to the business rules. The third step is to ask domain experts for an acceptable timeframe for updates to occur to each of the dependents on each of the aggregate root entities. This will be either a, immediate, or b, eventually. And when I say eventually, it could be N, number of seconds, N, number of minutes, N, number of hours, N, number of days, and so forth. But you get the point, updates will either be required to be immediate, or eventual. Fourth, you want to house all of the 3a, or immediate updates, inside a single aggregate. So for example, in aggregate type one, if you were to conclude with a guidance from domain experts that the entity that is dependent on the root entity of aggregate type one to be an immediate update, then you're going to house that entity under the root entity for aggregate type one. Because it requires immediate update or transactional consistency. If you ask a domain expert, and they say that an update can be eventual, then plan to update all 3b, or eventual, dependencies eventually. Here's an example. I'm here looking at aggregate A1. I have another aggregate A2, and yet another aggregate C14. When I have a discussion with domain experts about the time dependency of updates between A1 and A2, domain experts say, yes, those must be immediately updated. They must be consistent at all times. In that case, what we're actually going to do is fold aggregate A1 and aggregate A2 into a single aggregate instance. Or aggregate type. We're gonna call that, aggregate A12. But notice, that when I have a conversation with domain experts, I learn that aggregate A1 and aggregate C14 can be eventually consistent, and that they should be up to date within about 30 seconds. In that case, aggregate A1 and aggregate C14, will be consistent by means of a domain event. Therefore, because I have collapsed A1 and A2 into aggregate A12, aggregate A12 will publish a domain event which will eventually have an impact on aggregate type C14 instances, or one instance. And that aggregate C14 will be updated eventually, within approximately 30 seconds.

- You want your aggregate designs to accommodate unit testing. It's important to unit test your aggregates. Now going back a few lessons, I discussed using unit tests as acceptance tests. That's different. Those acceptance tests are really holding the model to the design of the ubiquitous language according to domain experts. So as you're developing your ubiquitous language you are creating unit tests as acceptance tests. But these unit tests that I'm talking about now are different. Using Rule 2, Design Small Aggregates, will have you to make aggregates testable. They will create small aggregates that are considerably easier to test than large cluster aggregates. Unit tests again are different from acceptance tests. In this case what we're testing is for the correctness and robustness of each of the aggregate components.

- [Instructor] In summary you learned the importance of designing with a consistency boundary, to maintain your business constraints. You learned about the various parts of an Aggregate, and how to model them. You learned the four rules of effective Aggregate design. You learned how to model an Aggregate's attributes. You learned the importance of avoiding Anemic Domain Model. You learned how to model the behavior of an Aggregate. You learned to always adhere to the ubiquitous language when modeling your Aggregates. You learned to use the proper level of abstraction, always adhering to the ubiquitous language. And you learned how to right-size your Aggregates and to unit test them.

