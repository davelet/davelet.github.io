---
layout: post
title: 领域驱动设计DDD入门5：聚合
categories: [dev]
tags: [ddd]
---
第五节课我们讲一个战术工具：聚合。聚合可以用于设计小型高效的对象集群，这些集群使用事务管理一致性约束。这节课先解释为什么要使用聚合，接下来介绍四个总体设计经验法则，然后是用于建模聚合的技术，随后考虑为什么在对聚合进行建模时应谨慎选择抽象级别。最后，我们考虑如何确保将聚合设计为可测试的单元。

每个有界上下文中都有几个概念。以敏捷项目管理产品为例，BacklogItem，Release，Sprint，以及Forum，Discussion，Post，Calendar和CalendarEntry。这些就是聚合。注意，这里还有一个概念，“Dicussion”，不是聚合是一个单独的值对象。我们不会关注值对象，我们将深入探讨聚合及其使用的原因。聚合具有几个不同的部分：聚合具有一个称为聚合根的根实体。聚合根实体还可以包含其他实体和值对象。在整个内部是事务边界。
这里有两个单独的聚合，其中聚合根实体将整个聚合代言。因此我们关注聚合根。它这是一个实体，它命名了整个聚合，并且具有全局唯一标识，因此该聚合对于所有其他实体或相同类型或不同类型的聚合而言是全局唯一的。
集合就是事务一致性的边界。在聚合内，事务结束时所有内容必须保持一致。在操作的开始启动一​​个事务，然后传播到聚合整体。事务正在进行，聚合根据对其执行的操作进行更改，然后完成。之后，事务将提交。该事务没在聚合2的作用域。在另一个单独的事务中，聚合2将被更新。因此，聚合就是事务边界。

# 聚合设计四法则
> 我们称这些法则为“聚合设计经验法则”

第一是保护聚合边界内的业务不变量，第二是设计小的聚合，第三是只通过标识访问其他聚合，第四是通过最终一致性更新其他聚合。

## 保护业务不变量
先看一个例子：产品聚合和冲刺聚合，每个聚合都被自身的事务控制。产品聚合的聚合根是product，它有引用指向ID及其产品待办项，注意和待办之间是一对多，那里是星号。冲刺聚合的聚合根是sprint实体，也有一个冲刺ID和一组已提交待办项，也是一对多关系。因为各自是独立的事务，所以它们的业务部变量就被保护起来了。
<div align="center">
<img width="70%" src="/images/post/ddden4.png">
</div>
待办项也是聚合，聚合根是backlog item，也有ID和多个任务。注意待办有状态值，值可能取planned/committed/done。任务呢有剩余时间，是代表小时的整数。当待办项里的所有任务剩余时间都是0小时时，待办项的状态就是done。所以即使其他所有任务都是0了只要还有一个任务的小时数不为0，待办也是committed。只要最后一个任务的小时数设成0了，在同一个事务中就要把待置为done。这是业务上的一致性约束，必须遵守，只能在同一个事务完成。
<div align="center">
<img width="50%" src="/images/post/ddden5.png">
</div>

## 聚合尽量小
<div align="center">
<img width="70%" src="/images/post/ddden6.png">
</div>
如图所示，可能会把产品所有的待办、发布、冲刺都放进产品聚合里。这样就太大了，需要拆分。因为有可能不同用户在不同事务会对同一个产品进行操作，这么大的聚合可能就会失败。比如有人修改发布有人修改待办，因为竞争的存在，同一时刻只会有一个事务成功，其他都会因为数据不一致而失败。另外太大的聚合占用内存也很大，没有必要啊，加载慢，GC也频繁了。
<div align="center">
<img width="60%" src="/images/post/ddden7.png">
</div>
所以我们把它拆成4个聚合。产品聚合不再包含待办、发布和冲刺了。这样可以防止事务竞争，也降低了内存占用。反正是很大程度的改善。

## 通过标识引用

标识就是实体的ID。在上面我们的四个聚合中，新拆分的三个聚合都需要知道他们属于哪个产品，产品聚合是它们的父聚合。怎么知道呢？他们不需要有引用指向产品实体，而只要有实体ID的引用即可。
<div align="center">
<img width="70%" src="/images/post/ddden8.png">
</div>
这么做的一个好处依然是占用内存小，另一个好处是当你修改子聚合的时候不会修改父聚合，不然也就破坏了第一个经验法则。

## 最终一致性
比如当待办被提交到冲刺时，待办是知道被提交到哪个冲刺的，它有冲刺的标识。事务完成时，这个待办关联的冲刺ID就被持久化了。但这时候冲刺还不知道有新的待办提交过来，但最终冲刺聚合会在一个新事务中记录有待办加入了。为什么？因为待办提交的时候会发布提交事件，敏捷项目管理软件会对这个事件做出响应，发现对冲刺有影响，于是冲刺更新自己的信息。原理是什么？就是“发布有界上下文”，三个小聚合都在这个上下文中，通过消息机制完成同步。订阅有界上下文会接收到事件消息，冲刺就是提交事件的相关方（第二堂课中说过）。

# 聚合建模
首先要警惕“贫血模型”。贫血模型容易上手，很多人陷入其中不能自拔。贫血模型就是模型里面没有任何行为，只有一大堆的getter/setter。

那怎么办呢？首先要记住聚合是事务一致性边界。你肯定会为聚合建模聚合根实体的，根还可能引用其他实体，也可能引用其他值对象。你肯定也会为聚合根起一个和聚合一样的名字。
<div align="center">
<img width="70%" src="/images/post/ddden9.png">
</div>
比如这个产品聚合的聚合根就叫产品product。从代码中可以看到这个根实体继承了Entity类，当然这里看不出它的必要性。根内部呢，引用了租户ID和产品ID。产品还有两个熟悉，名字和描述，都是字符串。访问控制呢？get是公开的，set是私有的。为啥会有私有的？这很重要，你注意不到就可能变成贫血模型。贫血模型中，不经过任何行为就能修改熟悉，而这里你不能访问setter了，只能通过行为来控制。行为才是公开的，用户必须使用行为。
<div align="center">
<img width="70%" src="/images/post/ddden10.png">
</div>
这里增加了一个公开行为：PlannedProductBacklogItem()，是根据敏捷项目的通用语言设计的，会把backlog置为planned（上面说过backlog的三种取值）。UML中还能看到其他行为，总之你需要根据通用语言设计行为定义。这是很重要的DDD实践方法。做为程序员，我们不仅仅是给方法或者聚合根命名，我们要追随我们项目的通用语言进行建模。这样才能满足业务需求，设计出高效的聚合。

As we model our ubiquitous language within our bounded context, remember to choose abstractions wisely. Here we're going to look at our Core Domain, the Scrum Project Management Application or service, and its natural ubiquitous language. The ubiquitous language that is spoken by the domain experts is naturally using concepts such as Product, BacklogItem, Release, and Sprint. These are the natural language elements or concepts within Scrum. They fit, and therefore the agile project management context model should be designed with these concepts in mind. However, it's also possible to take a completely different direction when modeling for a ubiquitous language. What if the developers on the project decided to try to overly abstract the model? They would actually, most likely, be ignoring the natural ubiquitous language spoken by a domain expert, and perhaps they would instead of modeling Product, BacklogItem, Release and Sprint, decide to use something like a ScrumElement. You can imagine that a Scrum Element could be used to model a Product and a BacklogItem. The ScrumElement would no doubt have a type name, field, or property, and that type name, field, or property would be set to the string, Product, when we're representing a product in the ScrumElement, and BacklogItem when we're representing a BacklogItem in the ScrumElement. But what about Release and Sprint? How would they be modeled? Well, the ScrumElementContainer might be a worthy use. The ScrumElementContainer would contain ScrumElements, and the ScrumElementContainer would have a type name that would be set to the string release when a release is being represented, and would be set to Sprint when a sprint is being represented. But, do you notice, the pitfall that we're facing here? We are moving against the tide of the ubiquitous language that is naturally spoken in Scrum. ScrumElement, and ScrumElementContainer do not properly represent the actual concrete types that naturally live within Scrum. So let's consider some of the problems that you will face if you use wrong abstractions in your model design. First and foremost, you ignore the natural ubiquitous language. Second, it's hard to model the details of specific types. For example, the ScrumElement doesn't fully represent a product or a BacklogItem. It represents something far more general. There are also going to be special cases for complex and the a-complex class hierarchy. The special cases will no doubt occur because of the differences between products and BacklogItems, and as much as we would like to think that we can create a general purpose type of ScrumElement for Product and for BacklogItem to represent both of those, it's just going to fail, because of the special cases in each of those different types. There will likely be more code than necessary, than if you were modeling explicitly. General purpose concepts require much more code than concrete's concepts. The wrong abstractions will also influence the user interface. The user interface will not follow the basic shape of the domain model that is the natural types of the ubiquitous language. Rather, it will tend to follow the shapes of the highly abstract types. This will also likely impact the user negatively. You'll waste a lot of time, and a lot of money pursuing the wrong design. It just will not work in the long run. And you'll spend a lot of time trying to maintain and work around the special cases. The imagined future proofing that you're attempting to design into the model will definitely meet with failure, because the future concepts that you imagined, that you can defensively code for today, will not be realized as you imagined them. In order to avoid all of the problems that you would face with an overly abstract model, model explicitly per the natural ubiquitous language. In doing so, you will adhere to the mental model of domain experts. This will create an understandable model. A model that can actually be understood by domain experts, because it does adhere to their mental model. It protects the organization's software investment, which then naturally leads to a saving of time and money.

How do we right-size aggregates? Here we have aggregate type one, again. Aggregate type one has an aggregate root entity. It also holds an entity part, and it holds a value object part, is this the right size for aggregate type one? How do we know? Should aggregate type one hold the entity and hold the value object? Is there some sort of guidance that will help us to understand how to model this aggregate effectively? There is. And I'm gonna go through those steps now. These are some modeling steps that can help you to understand if you have right-sized your aggregate. The first step is to start with the rule of thumb number two, design small aggregates. So, as a first step, what you actually want to do, is design all of your aggregates with just one entity, where possible. Unless you absolutely know that a specific entity is needed. So, in this previous example of aggregate type one, you would actually break up aggregate type one to have a root entity and to make the entity that it was holding a separate aggregate. Just as a first step. The next step is to then apply rule one, protect business invariants inside consistency boundaries. Make a chart, this chart will have the names of all aggregate types in a list and the list will also have the dependents for each of those aggregates. In other words, the other aggregates that will updated in some time frame, according to the business rules. The third step is to ask domain experts for an acceptable timeframe for updates to occur to each of the dependents on each of the aggregate root entities. This will be either a, immediate, or b, eventually. And when I say eventually, it could be N, number of seconds, N, number of minutes, N, number of hours, N, number of days, and so forth. But you get the point, updates will either be required to be immediate, or eventual. Fourth, you want to house all of the 3a, or immediate updates, inside a single aggregate. So for example, in aggregate type one, if you were to conclude with a guidance from domain experts that the entity that is dependent on the root entity of aggregate type one to be an immediate update, then you're going to house that entity under the root entity for aggregate type one. Because it requires immediate update or transactional consistency. If you ask a domain expert, and they say that an update can be eventual, then plan to update all 3b, or eventual, dependencies eventually. Here's an example. I'm here looking at aggregate A1. I have another aggregate A2, and yet another aggregate C14. When I have a discussion with domain experts about the time dependency of updates between A1 and A2, domain experts say, yes, those must be immediately updated. They must be consistent at all times. In that case, what we're actually going to do is fold aggregate A1 and aggregate A2 into a single aggregate instance. Or aggregate type. We're gonna call that, aggregate A12. But notice, that when I have a conversation with domain experts, I learn that aggregate A1 and aggregate C14 can be eventually consistent, and that they should be up to date within about 30 seconds. In that case, aggregate A1 and aggregate C14, will be consistent by means of a domain event. Therefore, because I have collapsed A1 and A2 into aggregate A12, aggregate A12 will publish a domain event which will eventually have an impact on aggregate type C14 instances, or one instance. And that aggregate C14 will be updated eventually, within approximately 30 seconds.

You want your aggregate designs to accommodate unit testing. It's important to unit test your aggregates. Now going back a few lessons, I discussed using unit tests as acceptance tests. That's different. Those acceptance tests are really holding the model to the design of the ubiquitous language according to domain experts. So as you're developing your ubiquitous language you are creating unit tests as acceptance tests. But these unit tests that I'm talking about now are different. Using Rule 2, Design Small Aggregates, will have you to make aggregates testable. They will create small aggregates that are considerably easier to test than large cluster aggregates. Unit tests again are different from acceptance tests. In this case what we're testing is for the correctness and robustness of each of the aggregate components.


