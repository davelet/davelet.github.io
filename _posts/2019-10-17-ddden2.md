---
layout: post
title: 领域驱动设计DDD入门2：有界上下文和通用语言
categories: [dev]
tags: [ddd]
---

这堂课我们讲有界上下文和通用语言，这是两个重要的战略设计工具。之后讨论领域专家和业务驱动，然后看一个没有使用DDD的例子进行对比。最后是通用语言。

---

战略工具不少，其中最重要的两个就是这堂课的有界上下文和通用语言。什么是有界上下文？它是一个带有明确边界的域，在里面通过通用语言进行建模。能听懂吗？

首先，边界上下文是一个内容上或者语义上的边界，在边界内部所有东西都是和模型明确关联的。在模型中我们提到一个词的时候我们明确知道它的含义，任何东西都有明确含义，含义必须是和通用语言关联的。“通用”的原因是整个团队都用这个语言，在领域内是共同的语言。这个语言是直白的（不难理解的），日常交流就能对应软件模型。从另一个角度看，这个语言又不是通用的，因为它不是整个公司都用的语言，它仅仅在单个项目内使用。这个语言决定了这个项目有多大，因为讲这个语言的人都是这个上下文内的。而团队决定了通用语言是什么样子的，团队内至少有一维领域专家来领导通用语言的成形。领域专家并非一个头衔（所以不用去特意雇佣一个），而是团队内对特定业务领域知识最熟悉的人群，也是引领团队、项目前进方向的人。团队内的开发人员和领域专家交流、协作，一起创建通用语言。

> 我们把通用语言和人类的语言对比一下。汉族人讲汉语，朝鲜人讲朝鲜语，日本人讲的日语。当你从东北跨入朝鲜时，你听到的语言就变了。这就类似从一个边界上下文进入另一个边界上下文。另外日本人跟我们学习了不少字词，但有些词含义上还是有差别。在不同的边界上下文中，相同的词可能含义不同，不同的词也可能含义相同。所以通用语言在特定的上下文内才有含义

使用DDD及其战略工具的一个原因是不用就会有问题（啥？人择原理啊...）。一开始我们可能有简单的模型能满足业务需求，多次迭代以后，模型就会混乱，变成一个大泥球。 -- 我先确认一下，你不会以泥球为傲吧？你肯定会尽可能避免这种情况的。

DDD的基本准则之一是跟着领域专家走。前面说过领域专家一直研究业务，他们为业务发展指明方向。他们的眼光能带领公司业务向前快速发展，在市场上提升竞争力。他们能对我们建模给出专业意见。每个领域内的专家都对至少一个领域精通，比如说保险业内有证券专家，有债权专家。这些领域都有凭单的概念，但凭单在证券领域和债权领域含义不同。尤其是证券的凭单和保险检查的凭单含义又一样。这个模型该怎么建？如果用同一个模型去代表是不合适的。在DDD领域中，我们想要识别、区分业务领域，每个领域有自己的模型。所以前面这个例子需要三种凭单模型对应三种边界上下文。这样就满足了不同领域的需求，边界明确的建立了凭单模型。这就是DDD的第一步，感觉如何？

为了增强使用DDD战略设计的需要，我们看一个例子。这个例子是一个敏捷项目管理软件。敏捷项目的工具是project、backlog、sprint等，估计大部分人都熟悉这些，不熟悉百度一下也很清楚。我简单说一下：project，项目，就是团队要开发的软件；backlog，待办，是一个用户故事（user story）和一些内部任务，执行期间待办会被有序完成，可以分布在多个连续的sprint中；sprint，冲刺，是给定时段内要完成的待办集合。明白了吧：冲刺包含待办，是时间敏感的，待办包含任务，任务有估时；任务的总时间接近冲刺的时间。等你完成这些建模，新需求来了：我们有很多目标公司，每个公司的用户有不同的权限，不同用户在这个软件上能做的事情不同，他们只能看见自己的待办和任务。另外还要有论坛，对项目、冲刺、待办、任务等进行讨论；还要有日期控件，可以记录里程碑、计划会议、回顾会议、项目发布日期等。等你重新建模完成，又有新需求来了：我们的软件是收费的，而且有收费级别。不同公司交费不同，他们能用的功能就不同。我们需要记录公司对待收费功能的使用情况，你判断对他们推销下一级别是否有效。之后又有需求：记录每个组织、每个用户的使用情况，他们在各个待办上面花费的时间等等。所以我们要增加一个资源管理，根据不同成员的能力规划他们的任务。这太有用了，每个人都最大可能的被发挥作用。你发现了吗？随着需求变更次数的增多，我们的模型不停滚动，变成了一个大泥球。这太有问题了。很多企业都是眯着眼走到黑，最终出现大泥球。

怎么避免这种情况呢？边界上下文就派上用场了。再说一次，边界上下文帮助我们在域内建模。按照通用语言，什么属于边界上下文，什么不属于？什么在模型内部，什么在模型外？这都很重要。不该在模型内的就踢出去。这有什么好处？通过把领域专家和开发人员放在一起，而不是分成“写文档的”和“写代码的”两组人可以让他们充分协作，清晰地得到边界上下文内的通用语言。领域专家是业务流程的专家，是这个领域知识最丰富的人。而在敏捷项目中，专家是待办、冲刺、任务等等，管理这些最擅长的人。毕竟他们是敏捷专家。开发人员侧重技术，他们擅长和爱好的就是开发软件。不过开发人员不能纯粹地转进技术研究中不出来，那样会脱离业务实际，如同盲人骑瞎马。开发要和领域专家一起工作，以确保他们的目标一致。这样我们在领域专家和开发人员之间可以得到一个反馈环。你意识到他们之间不是命令和控制的关系吗？领域专家不是让开发去干这个去干那个，而是不断的协作反馈，相辅相成的形成了业务专家和技术专家。大家都会主动思考，因为反馈环形成以后问题就会自然地出现：开发人员在想如何用技术服务业务，业务人员在想业务流程如何转换成技术实现。这些问题不停出现，就有了思维突破，关键想法接踵而至。所以团队一定要有领域专家，少也得有一个。

打烂泥球的一种练习方式就是挑战当前的模型，尝试用边界上下文和通用语言去重新建模，不仅要思考什么属于边界内，还要考虑什么不在边界内。所以我们练习一下，挑战并建立统一战线，首先质疑敏捷项目，租户、用户和许可是否属于它的通用语言。如果你想访问任何敏捷资源，你可能找不到任何地方有对租户、用户、权限或者类似的引用。实际上他们是一个建模概念，但它们对敏捷项目管理的成败至关重要，却不属于任何边界上下文。就算我们不考虑租户、用户、许可这些概念，我们依然需要考虑构造团队的那些个体组，以及项目Owner和成员。所以我们在边界上下文内给团队、Owner、成员建模。后面再说怎么把他们和租户、用户、许可集成起来，现在我们再次挑战：账户、支持计划、支付、事件属于敏捷项目管理工具吗？完全不是！我们再看一次敏捷的引用，发现根本找不到这些概念，他们决不会成为我们的模型。时间资源呢？资源管理器、规划、可用性？尽管从概念上讲这些可能非常重要，但对于敏捷团队的整体而言，它们并不属于敏捷模型本身。它们没有上下文，因此应从我们的核心模型中删除。另一方面，我们确实有志愿者的概念。志愿者是分配了任务的团队成员，他们自愿完成任务，因此是志愿者。所以我们想为他们建模。使用日历条目支持提醒、里程碑、目标日期、回顾和计划会议怎么样？这些可能与敏捷模型保持一致，实际上，在敏捷中我们确实讨论了里程碑、回顾和计划会议。但是现在，这些超出范围了。重要的是，我们意识到在产品、待办事项、发布和冲刺中，团队希望能够就项目的每个领域进行线程化的讨论。因此我们想在我们的核心领域内建立讨论模型。我们将与另一个有界上下文进行集成，并且该单独的有界上下文将处理协作。那个上下文有论坛、讨论、发帖功能，持有大多数模型；而我们的核心模型只是线程化讨论功能。所以核心模型很小。在产品、待办、发布、冲刺中都可以进行线程化的讨论；待办中还有任务，任务有志愿者和预估；发布有计划中的待办，冲刺有提交完的待办，产品有Owner和成员。我们的核心领域在语言上是合理的，反映了敏捷的专业知识，不多不少。那么其他概念呢，那些我们拒绝掉的概念？它们可能属于其他不同的上下文。每个DDD项目都会有多个上下文。

- So, how do we actually develop a ubiquitous language? Sometimes when I work with teams, it takes a little time for them to loosen up and collaborate with domain experts in order to create a ubiquitous language. One of the tools that you'll want to use is developing scenarios, scenarios that are specifically focused around a domain model. So, these scenarios are not just use cases, they're not just user stories, they are literally talking about scenarios of how specific objects or concepts within your domain model collaborate with other concepts within the domain model, to accomplish a specific scenario goal. Now, what I'm going to do, is introduce you to a scenario in the ubiquitous language of our Scrum project management application. This reads, allow each backlog item to be committed to a sprint. The backlog item may be committed only if it is already scheduled for release. If it is already committed to a different sprint, it must be uncommitted first. When the commit completes, notify interested parties. OK, there we have a scenario about our domain model. Do you notice that there are some specific domain model concepts that are named within this scenario? For example, backlog item, backlog item is a concept that we've already discussed as being part of our domain model. Look at sprint, sprint is another concept. And, we also have some verbs or actions that are named, for example commit, so we are going to commit a backlog item to a sprint. And we have some constraints that are spoken about here, for example, if a backlog item is going to be committed, it must also be scheduled for release prior to the time that it can be committed, so that's a constraint. If it's already committed to a different sprint, then it has to be uncommitted from that current sprint first, then it can be committed to the target sprint that we want it in now. And when the commit completes, we're going to notify interested parties. So this is a starting place for a scenario, what do you think, is it complete? I don't think so, but the great thing about domain-driven design is, we can constantly be on a quest to improve the scenarios that we come up with, and, related to that obviously, is to improve the model, the code that we're writing to actually implement this scenario. So, with this starting point, how we can actually refine this scenario? One thing that we can do is improve the scenario by asking, who does this, and, who are the interested parties? Well let's answer the first question, who commits the backlog item to a sprint? Well, actually, when we're talking about a normal human Scrum team, maybe the entire team agrees on committing a backlog item to a sprint, and someone will move a sticky note to the to do column of our task board, and this will be, in essence, committing the backlog item to the sprint. But, when we're talking about software, and a software management tool for managing Scrum projects, we're probably going to have to say that a specific user role should commit backlog items to sprints, that is, maybe the best choice being the product owner, so we're going to say as a team, that product owners ultimately commit backlog items to sprints. But think about that for a moment, if you have used Scrum, you can easily understand that as a Scrum team, we don't want the product owner to be able to commit a backlog item to a sprint any old time they want to, the entire team needs to agree to the commitment, they have to put themselves under commitment to deliver a specific backlog item within a specific sprint, so we don't want the product owner doing this on their own. How do we solve this problem? Well the team has to think about this, but by asking who does this, remember we have that feedback loop now between software developers and domain experts, and when we ask who, those question marks, it leads to an interesting breakthrough, which I'll identify in just a moment. But one thing that I want to tell you is, if it helps to improve your scenarios, you can actually also address the personas, the individual roles who are performing these actions within a scenario. For example, if it helps us to identify the product owner as Isabel, Isabel commits a specific backlog item, the View User Profile backlog item to a specific sprint, the Deliver User Profiles sprint, if it helps, add those. Now I think in our specific situation, it doesn't add a lot of value, because the personas don't really influence how this particular scenario will be accomplished, but if it helps, add those in. But now, back to the question of, by asking who, what kind of breakthrough did we actually accomplish as a team? What happened is, our product owner, in committing the backlog item to the sprint, forced us to think about the situation as a team, as we model, how can we allow them to commit a backlog item to a sprint, but at the same time, not enforce their will on the team without the team's input? Notice what this has led to. The product owner commits the backlog item to a sprint. The backlog item may be committed, and here's another constraint, only if it is scheduled for release, that existed before, but now notice the new constraint, and if a quorum of team members have approved commitment. Ah, interesting, that's a real breakthrough, you can imagine a team going into a sprint planning meeting, each of the team members has some sort of mobile device with them, it may be their phone, it could be a tablet of some kind, or their notebook computer. They go into the planning meeting, and as they are discussing each of the backlog items that could potentially be committed to a sprint, so candidate backlog items, they either agree or disagree to commit those backlog items to the sprint, and when they agree, they simply record their agreement on their mobile device, and that agreement to commit the backlog item to the sprint, makes up a quorum of team members, let's say that we set that number to three or four, if our team is at least six in size, then we want to have a quorum of at least four individuals, and if those four individuals vote to agree on committing that backlog item to a sprint on their mobile device, then, the product owner can commit the backlog item to a sprint. Wow, this is a great breakthrough, and it adds a lot of value to our all-important core domain model. Notice also that we could improve this scenario by asking who in another way. When the commit completes, so when the backlog item is actually committed to the sprint, notify interested parties, who are the interested parties? Well, it could be a lot of different interested parties, or at least a few, but there's one very important interested party that we're concerned about, that is, the sprint itself, because the backlog item has been committed to the sprint, but the sprint does not know, yet, that the backlog item is committed to it, and remember our sprint has committed backlog items associated with it, so it definitely needs to know which backlog items are committed to it. So, how would our scenario be changed? If it is already committed to a different sprint, it must be uncommitted first, we knew that before. When the commit completes, notify the sprint from which it was uncommitted and the sprint to which it is now committed, so, how's that going to happen? Well, that discussion will be taken up further, as we talk about aggregates and domain events, but, we are going to make sure that the sprint has the opportunity to know that the backlog item is committed to it. There's another thing that comes up here when we think about this, it looks like the backlog item knows about the sprint commitment, in a different transaction than the sprint will learn about the backlog item commitment, so, eventual consistency, and we'll also talk about eventual consistency later, but this is an important thing to recognize within the scenario, that this is an opportunity for parts of the model to be out of sync for a short period of time, but, soon to be brought into harmony, which allows for better scalability, and even better performance in some cases. So this is our whole refined scenario now, let's read through it. The product owner commits a backlog item to a sprint. The backlog item may be committed only if it is already scheduled for release and if a quorum of team members have approved commitment. If it is already committed to a different sprint, it must be uncommitted first. When the commit completes, notify the sprint from which it was uncommitted and the sprint to which it is now committed. What do you think of that scenario? It's pretty good, we can actually start writing tests and start implementing our model code, to prove out that this scenario actually works. How does that happen? Well, we could use one of two different approaches. For example, we could use specification by example, what's also referred to as, behavior-driven development or BDD. Here's an example, we have a Given-When-Then scenario, where we break a scenario, such as the product owner commits a backlog item to a sprint, into three different sections. The given, which is, where our model is in the point in time, and how its data currently is set, and when a specific business operation occurs, then we can assert that certain conditions are met, so let's see what those are. Again, our scenario is labeled, the product owner commits a backlog item to a sprint. Given a backlog item that is scheduled for release, that was one of our requirements, our constraints, and the product owner of the backlog item, because we need a product owner in order to commit the backlog item to the sprint, and a sprint for commitment, and also a quorum of team approval for commitment, so those are our givens. If we have those objects set up for us when the product owner commits a backlog item to the sprint, so that's the actual primary operation that we're interested in, then, the backlog item is committed to the sprint, so we can assert that the backlog item itself knows that it is now committed to a sprint after that operation, and we have a backlog item committed event that has been created. Now, some teams use this approach and actually implement this scenario with software behind the scenes, they create what's called an acceptance test, they take the criteria for the acceptance test, and they implement it as a BDD test, implementing also the model that helps us achieve this test, and then execute the scenario as an acceptance test off of this scenario. It can be pretty tempting to try to keep up with this level of software accuracy and acceptance testing, but it can also add some overhead, I'm not going to vote for or against this approach, just be aware that there is a learning curve involved in this, and you probably also need some expert advice before you go down this path, but understand that you can still use the Given-When-Then approach without implementing the backing tests, just to allow for good communication and collaboration on your team. Another approach that can be used is to develop a unit test specification. Notice that I've set up this test, in C Sharp in this case, that is named ShouldCommitBacklogItemToSprint, and then notice also that in the code, I've written three different comments, Given, When and Then, so ultimately, this unit base test follows much the same approach as the scenario that we just previously looked at, but we're using a unit test approach, rather than implementing a specification test behind the scenario that was written. In this case, we have, as given, a BacklogItemScheduledForRelease, we have a ProductOwner, we have a SprintForCommitment, and we have a QuorumOfTeamApproval, so this is the given, these are, in essence, the fixtures to our unit test. And then, we have our when clause, which says when a backlog item is committed to a sprint with a product owner and a quorum of team commitment, or team approval, then we can assert that the backlog item is committed, that that is a true statement, and, we can ask the backlog item for the events that were created on it when that operation occurred, the CommitTo, and we're going to expect a BacklogItemCommitted domain event, and we can assert that that BacklogItemCommitted domain event is not null. So now we've accomplished much the same thing that could be accomplished with the previous BDD, or specification by example scenario, but it can be much easier, much quicker, to implement this as a unit test.

- By now, you're probably wondering, "What does a bounded context actually look like internally? "Is it just the domain model? "What is the architecture of a bounded context? "What are some of the architectures "or architectural patterns that can be used "for a bounded context and within a bounded context?" Well, you have some options here. This architecture diagram illustrates a ports and adapters architecture. This has also been called the hexagonal architecture, some call it the onion architecture, maybe you even have another name for this architecture. But the strength of this architecture is that we have, at the center or the middle of the architecture, a domain model. This is at the heart of the software. Around the domain model, we typically have some sort of application services. The application services manage our transactions for us, perhaps they manage security as well, but they also are task managers for the use cases that the software needs to perform. Ultimately, it's the application services that invoke methods on the domain model to carry out the operations of our scenarios that we've just discussed. On the outside of the architecture, the dark blue part, are the adapters for the various ports. Now, you can think of these adapters in a few different ways. I like to think of them as ports that are incoming request operations from the outside world. At the top, toward the left of this diagram, we see a globe. This represents the world wide web or browsers. So, here we have a browser that is making requests of our bounded context and those requests are being adapted by a port adapter specifically made for browsers, and that port adapter is adapting the requests to the internal application services or API so that those application services can delegate to the domain model to have the actual operations executed. Below the representation for browsers is a mobile phone. Perhaps we have a mobile phone that's making requests to our architecture. We also have the cloud. Maybe this is integration from other bounded contexts. And we have a messaging port with a lightning bolt. This messaging port is accepting incoming messages that, in turn, like all the other adapters there on the left-hand side, will be adapted to the internal model, which is represented by the domain model and then the surrounding application services or API. So, all of these internal requests are focused on adapting to the internal API, the API then delegates to the domain model. On the right-hand side of the diagram, you see output ports. These are opposite of the input ports that we were just talking about. The output ports can be, for example, repositories that talk to a relational database, or perhaps to a document database, or to an in-memory grid. We have a lot of different options there. We also have an outgoing adapter that goes to the lightning bolt or the messaging mechanism. So, we're accepting messages in and we're producing messages or sending messages through our output port as well. So, this architecture well-represents a typical architecture that can be used with domain-driven design. Here's another view of that architecture tipped on its side. We have input adapters and output adapters at the outside of the architecture. Internally, we have our application services and our application services call the domain model. Within our input adapters we may have security, we may have our user interface and we may have RESTful representations. Also, in our application services, have security, transactions, task coordination, use case controllers, and so forth. Within our domain model, which we've been talking about, we have our entities, we have our business logic, we have domain events. And in our output adapters, we may have repositories, documents, cache, and messaging. So, this gives you two different views of the same architecture. Other architectures or architectural patterns that can be used with domain-driven design are numerous. For example, in lesson six, we're going to talk about an event-driven architecture and event sourcing. This will teach you how to use domain events in an architectural way to send notifications of facts that have occurred in your domain model to other bounded contexts. You'll also have the ability to use command query responsibility segregation or CQRS. We won't talk about that much in this course but there is other literature that you can derive information from about how to implement CQRS. Reactive and the actor model can also be used. This is an area that I like to specialize in, reactive software development with the actor model. And this is a very clear and very powerful approach to implementing both an event-driven architecture and CQRS within our bounded context by the use of concurrency with actors. And there's also REST or representational state transfer, which we can use in a DDD environment, and microservices as well as service-oriented architecture, whichever way you appreciate that discussion being defined. So, you can use DDD with microservices, you can use DDD with service-oriented architecture.

- [Instructor] In summary you learned the pitfalls of putting too much into one model and creating a big ball of mud. The application of DDD strategic design. You also learned the use of bounded context and the ubiquitous language. And you learned how to challenge your existing model and unify according to your bounded context and ubiquitous language. You learned how to develop a ubiquitous language using domain model scenarios. And you learned how to use the architectural components, whether they're architectural patterns, or architectures, to develop your bounded context. Most importantly I think that you learned that DDD is not too difficult to put into practice yourself.

