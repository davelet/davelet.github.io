---
layout: post
title: 领域驱动设计DDD入门2：有界上下文和通用语言
categories: [dev]
tags: [ddd]
---

这堂课我们将有界上下文和通用语言。这是两个重要的战略设计工具。讲完有界上下文会讨论领域专家和业务驱动。然后看一个没有使用DDD的例子进行对比。最后是通用语言。

---

战略工具不少，其中最重要的两个就是这堂课的有界上下文和通用语言。什么是有界上下文？它是一个带有明确边界的域，在里面通过通用语言进行建模。能听懂吗？

首先，边界上下文是一个内容上或者语义上的边界，在边界内部所有东西都是和模型明确关联的。在模型中我们提到一个词的时候我们明确知道它的含义，任何东西都有明确含义，含义必须是和通用语言关联的。“通用”的原因是整个团队都用这个语言，在领域内是共同的语言。这个语言是直白的（不难理解的），日常交流就能对应软件模型。从另一个角度看，这个语言又不是通用的，因为它不是整个公司都用的语言，它仅仅在单个项目内使用。这个语言决定了这个项目有多大，因为讲这个语言的人都是这个上下文内的。而团队决定了通用语言是什么样子的，团队内至少有一维领域专家来领导通用语言的成形。领域专家并非一个头衔（所以不用去特意雇佣一个），而是团队内对特定业务领域知识最熟悉的人群，也是引领团队、项目前进方向的人。团队内的开发人员和领域专家交流、协作，一起创建通用语言。

> 我们把通用语言和人类的语言对比一下。汉族人讲汉语，朝鲜人讲朝鲜语，日本人讲的日语。当你从东北跨入朝鲜时，你听到的语言就变了。这就类似从一个边界上下文进入另一个边界上下文。另外日本人跟我们学习了不少字词，但有些词含义上还是有差别。在不同的边界上下文中，相同的词可能含义不同，不同的词也可能含义相同。所以通用语言在特定的上下文内才有含义

使用DDD及其战略工具的一个原因是不用就会有问题（啥？人择原理啊...）。一开始我们可能有简单的模型能满足业务需求，多次迭代以后，模型就会混乱，变成一个大泥球。 -- 我先确认一下，你不会以泥球为傲吧？你肯定会尽可能避免这种情况的。

DDD的基本准则之一来自于领域专家。前面说过领域专家一直研究业务，他们是业务前进的明灯。他们的眼光能带领公司业务向前快速发展，在市场上提升竞争力。他们能对我们建模给出专业意见。每个领域内的专家都对至少一个领域精通，比如说保险业内有证券专家，有债权专家。这些领域都有凭单的概念，但凭单在证券领域和债权领域含义不同。尤其是证券的凭单和保险检查的凭单含义又一样。这个模型该怎么建？如果用同一个模型去代表是不合适的。在DDD领域中，我们想要识别、区分业务领域，每个领域有自己的模型。所以前面这个例子需要三种凭单模型对应三种边界上下文。这样就满足了不同领域的需求，边界明确的建立了凭单模型。这就是DDD的第一步，感觉如何？


- To reinforce the need for using DDD's strategic design, I want to introduce you to a case study. This is in the area of Scrum Project Management. We're actually going to model, or look at the model, for a Scrum Project Management tool, where teams can use this tool to manage their products, backlog items, releases and sprints. I think most of you are probably familiar with Scrum, and so you can relate to this kind of software model. If not, it should be easy for you to figure out from the internet that a product, a backlog item, a release and a sprint are important concepts within a Scrum model. Just briefly, I'll introduce you to those ideas here. A product is the software that a team is developing. A backlog item is a user story and a set of tasks that a team will be executing on in order to deliver a release within a specific number of sprints, and the sprints have a backlog, or a set of backlog items, that are being worked on at any given time. So, just as a brief overview, you get the idea. Within a backlog item, you have tasks, and tasks have estimation log entries. So, we start out with a model that's clear and understandable. But then the team says, oh, well we also have our subscribing organizations, and each subscribing organization has users, and those users have to have permissions, so they will know what they can work on within the software model of product, backlog, item, release, and sprint. So, let's model those as well. Oh, yeah, we also want to have forum discussions, and discussions have posts, and we need to support calendars and calendar entries. We can leverage both of those concepts or sets of concepts so that we can have discussions about products, discussions about releases, discussions about sprints, backlog items and so forth, and we can use calendars and calendar entries to set milestones within the team's execution of Scrum. We can have calendar entries for planning meetings, for retrospective meetings, for meeting release dates and sprint dates and so forth. Let's model those as well. And then the team adds, well, we don't want to forget that we need to be paid for this, so each tenant will have an account, and the account will have a way to make a payment with a subscription to our software. Within the account, tenants will also have support plans, and the support plans will have records of incidences so that we can track how many times they've used their support plan. And then, the team adds, yeah, what would also be important is if the team could track its product owners and team members, and if those product owners and team members could be managed, so that we understand how much time-consuming resource each of those has on a specific sprint, or on a specific release within a specific product. So, let's have a resource manager, and let's schedule their time and schedule their availability so that we use members of each team on different teams. This will help a lot, this will be really valuable. And then, they say, well, you know what, if we are going to have reminders, milestones, target dates, retrospective meetings and planning meetings, let's model those explicitly from calendar entries, and this will be really valuable, this will make our model so much more valuable. Do you see where this is leading? By the time we design and implement all of the supporting concepts within the model that we've just now identified, we are being led to the development of a big ball of mud. This is very problematic, and many, many teams march down this cart path, as it were, until they reach the development of a big ball of mud.

- Well, the question is what tools can we use to avoid the big ball of mud? I've already introduced you to what a bounded context is and what the ubiquitous language is. So you can well imagine that we want to apply bounded context to that modeling situation that we just discussed that was leading the team to a big ball of mud, so that we can avoid coming into that situation. So let's talk about bounded context and the ubiquitous language further. A bounded context, once again, helps us to model what is in context. Semantically, what belongs in our bounded context according to our ubiquitous language, and what is out of context? What should not be in our model? This is just as important as defining what is in our model, that is defining what is not in our model, pushing those concepts out of our model that don't belong. How will we achieve that? It's by putting domain experts and developers together, collaborating together, not just separately writing specifications and building a gap between the two groups, but keeping them cohesively working together collaborating to develop a specific explicit, ubiquitous language within a bounded context. A domain expert will have knowledge in a specific area of the business, an area of expertise. In the industry of scrum, our domain expert will have knowledge of products, backlog items, releases, and sprints, and other concepts within scrum. After all, they are an expert in scrum. The developers, however, tend to be more technical. They like to twiddle bits of bytes. They like to use hexadecimal. They love their programming languages, whether it's Scala or Java or C#, whether it's JavaScript, they love to develop software. You probably know what I'm talking about. However, software developers need to be cautious not to be so wrapped up in technology and their programming languages, and bit and byte twiddling so that it leads them astray away from the actual business needs. Software developers need to work together with domain experts in order to achieve what the business needs are as a goal to develop competitive advantage. Here we have the representation of a feedback loop between the domain expert and the software developers on a team. Do you notice that it's not command and control? Domain experts are not issuing commands to developers to do this, to do that. This is a complete feedback loop where collaboration occurs, where experimentation occurs, where conversations and modeling exercises drive out the expertise that is needed on both sides of this feedback loop, both the business expertise and the technical expertise. Notice what's happened to the domain experts and the developers on the project. They are all now thinking question marks. Why, because when you form this feedback loop naturally questions will come to mind where the developers are wondering how does this work with the business, and the business will be wondering how does this work with technology? These questions that pop into mind are what lead to breakthroughs. Yes, the real significant aha moments will occur when you're having these deep dives in conversation within a software modeling team. That team includes domain experts, or at least one domain expert, on it.

- An exercise that we can use to break up the big ball of mud, that the team was being led into previously, is to challenge our previous model using bounded context and the ubiquitous language, to try to understand not only what belongs in the bounded context, but what doesn't belong in the bounded context. So let's take this exercise and challenge and unify, first of all by questioning does tenant, user and permission belong with the ubiquitous language of Scrum. So if you go to just about any Scrum resource, you'll probably not find anywhere, a reference to tenant, user or permission, or anything like that, actually, these modeling concepts, while overall important to the success of the Scrum Project Management Tool, do not belong in this specific bounded context, they're out. When you think about Scrum, although we don't imagine the concepts of tenant, user and permission, we still think about certain groups of individuals that make up a team, and those individuals are a product owner and team members. So when we model a Scrum Project Management Tool, we do want, within our bounded context, these concepts of team, product owner and team member. We'll talk about later, how we can integrate with the other model of tenant, user and permission in order to come up with this portion of our model for team, product owner and team member. Now let's challenge again, does the concept of account, support plan, payment and incident belong on our Scrum Project Management Tool? Not at all. Again, if we were to look at some Scrum reference, we would never find the concepts of account, support plan, payment and incident, these are definitely out of our model, they're out of context. What about time consuming resource? Resource manager, schedule and availability. While these are probably very important conceptually, to the overall operation of a Scrum team, they do not belong within the Scrum model itself. They are out of context, and so should be removed from our core model. On the other hand, we do have the concept of a volunteer. Volunteers are team members who are assigned to work on a task, they actually volunteer themselves to work on the task, and therefore, they become a volunteer within the task. So we do want to model a volunteer within our Scrum Project Management Application. What about the idea of using calendar entries to support reminders, milestones, target dates, retrospectives and planning meetings. Well, that actually might harmonize with our Scrum Model, in fact, within Scrum, we do talk about milestones, we do talk about retrospectives and planning meetings. We hold those, but for now, let's say that those are out of scope, it's going to take some more modeling effort, above and beyond our initial model for a Scrum Project Management Application, and so, let's put those aside for now. We're not going to address them. However, what's important is that we do recognize that within a product, backlog item, release and sprint, the team wants to be able to have threaded discussions about each of those areas of the project. So we do want to model a discussion within our core domain. How will we models that discussion? Well, we're actually going to integrate with another bounded context, and that separate bounded context deals with collaboration. It has forums, discussions and posts, we're going to allow that collaboration bounded context, to hold most of the modeling know how for discussions, and we can simply represent an area of threaded discussion, within our core domain model, the Scrum Project Management Application, and we're going to integrate with the collaboration context, so that we can support those threaded discussions within our core model. So when you consider the actual core domain, it's really quite small, we have products, backlog items, releases and sprints, within those, we can have threaded discussions, within our backlog items we have tasks, and each task has a volunteer, and a set of estimation log entries. Releases have scheduled backlog items, sprints have committed backlog items, and each product has a team with a product owner, and team members within that team. Our core domain is linguistically sound, reflects the expertise of Scrum, nothing more, nothing less. But what about all of the other areas that we rejected the concepts that we pushed out of our core domain, of Scrum Project Management, each of those likely belong to their own bounded context, for example, we already saw that there's a collaboration bounded context that has forums, discussions and posts, as well as calendars and calendar entries. But we also have another context, probably called something like, identity and access management that has tenant, user and role permission in it. We also have accounts and payments, under a support bounded context, we have support plan and incidents, and we probably want to manage human resources, through a resource manager, and a time consuming resource which schedules an availability in their own bounded context. And so you see that on every domain driven design project there will always be multiple bounded contexts.

- So, how do we actually develop a ubiquitous language? Sometimes when I work with teams, it takes a little time for them to loosen up and collaborate with domain experts in order to create a ubiquitous language. One of the tools that you'll want to use is developing scenarios, scenarios that are specifically focused around a domain model. So, these scenarios are not just use cases, they're not just user stories, they are literally talking about scenarios of how specific objects or concepts within your domain model collaborate with other concepts within the domain model, to accomplish a specific scenario goal. Now, what I'm going to do, is introduce you to a scenario in the ubiquitous language of our Scrum project management application. This reads, allow each backlog item to be committed to a sprint. The backlog item may be committed only if it is already scheduled for release. If it is already committed to a different sprint, it must be uncommitted first. When the commit completes, notify interested parties. OK, there we have a scenario about our domain model. Do you notice that there are some specific domain model concepts that are named within this scenario? For example, backlog item, backlog item is a concept that we've already discussed as being part of our domain model. Look at sprint, sprint is another concept. And, we also have some verbs or actions that are named, for example commit, so we are going to commit a backlog item to a sprint. And we have some constraints that are spoken about here, for example, if a backlog item is going to be committed, it must also be scheduled for release prior to the time that it can be committed, so that's a constraint. If it's already committed to a different sprint, then it has to be uncommitted from that current sprint first, then it can be committed to the target sprint that we want it in now. And when the commit completes, we're going to notify interested parties. So this is a starting place for a scenario, what do you think, is it complete? I don't think so, but the great thing about domain-driven design is, we can constantly be on a quest to improve the scenarios that we come up with, and, related to that obviously, is to improve the model, the code that we're writing to actually implement this scenario. So, with this starting point, how we can actually refine this scenario? One thing that we can do is improve the scenario by asking, who does this, and, who are the interested parties? Well let's answer the first question, who commits the backlog item to a sprint? Well, actually, when we're talking about a normal human Scrum team, maybe the entire team agrees on committing a backlog item to a sprint, and someone will move a sticky note to the to do column of our task board, and this will be, in essence, committing the backlog item to the sprint. But, when we're talking about software, and a software management tool for managing Scrum projects, we're probably going to have to say that a specific user role should commit backlog items to sprints, that is, maybe the best choice being the product owner, so we're going to say as a team, that product owners ultimately commit backlog items to sprints. But think about that for a moment, if you have used Scrum, you can easily understand that as a Scrum team, we don't want the product owner to be able to commit a backlog item to a sprint any old time they want to, the entire team needs to agree to the commitment, they have to put themselves under commitment to deliver a specific backlog item within a specific sprint, so we don't want the product owner doing this on their own. How do we solve this problem? Well the team has to think about this, but by asking who does this, remember we have that feedback loop now between software developers and domain experts, and when we ask who, those question marks, it leads to an interesting breakthrough, which I'll identify in just a moment. But one thing that I want to tell you is, if it helps to improve your scenarios, you can actually also address the personas, the individual roles who are performing these actions within a scenario. For example, if it helps us to identify the product owner as Isabel, Isabel commits a specific backlog item, the View User Profile backlog item to a specific sprint, the Deliver User Profiles sprint, if it helps, add those. Now I think in our specific situation, it doesn't add a lot of value, because the personas don't really influence how this particular scenario will be accomplished, but if it helps, add those in. But now, back to the question of, by asking who, what kind of breakthrough did we actually accomplish as a team? What happened is, our product owner, in committing the backlog item to the sprint, forced us to think about the situation as a team, as we model, how can we allow them to commit a backlog item to a sprint, but at the same time, not enforce their will on the team without the team's input? Notice what this has led to. The product owner commits the backlog item to a sprint. The backlog item may be committed, and here's another constraint, only if it is scheduled for release, that existed before, but now notice the new constraint, and if a quorum of team members have approved commitment. Ah, interesting, that's a real breakthrough, you can imagine a team going into a sprint planning meeting, each of the team members has some sort of mobile device with them, it may be their phone, it could be a tablet of some kind, or their notebook computer. They go into the planning meeting, and as they are discussing each of the backlog items that could potentially be committed to a sprint, so candidate backlog items, they either agree or disagree to commit those backlog items to the sprint, and when they agree, they simply record their agreement on their mobile device, and that agreement to commit the backlog item to the sprint, makes up a quorum of team members, let's say that we set that number to three or four, if our team is at least six in size, then we want to have a quorum of at least four individuals, and if those four individuals vote to agree on committing that backlog item to a sprint on their mobile device, then, the product owner can commit the backlog item to a sprint. Wow, this is a great breakthrough, and it adds a lot of value to our all-important core domain model. Notice also that we could improve this scenario by asking who in another way. When the commit completes, so when the backlog item is actually committed to the sprint, notify interested parties, who are the interested parties? Well, it could be a lot of different interested parties, or at least a few, but there's one very important interested party that we're concerned about, that is, the sprint itself, because the backlog item has been committed to the sprint, but the sprint does not know, yet, that the backlog item is committed to it, and remember our sprint has committed backlog items associated with it, so it definitely needs to know which backlog items are committed to it. So, how would our scenario be changed? If it is already committed to a different sprint, it must be uncommitted first, we knew that before. When the commit completes, notify the sprint from which it was uncommitted and the sprint to which it is now committed, so, how's that going to happen? Well, that discussion will be taken up further, as we talk about aggregates and domain events, but, we are going to make sure that the sprint has the opportunity to know that the backlog item is committed to it. There's another thing that comes up here when we think about this, it looks like the backlog item knows about the sprint commitment, in a different transaction than the sprint will learn about the backlog item commitment, so, eventual consistency, and we'll also talk about eventual consistency later, but this is an important thing to recognize within the scenario, that this is an opportunity for parts of the model to be out of sync for a short period of time, but, soon to be brought into harmony, which allows for better scalability, and even better performance in some cases. So this is our whole refined scenario now, let's read through it. The product owner commits a backlog item to a sprint. The backlog item may be committed only if it is already scheduled for release and if a quorum of team members have approved commitment. If it is already committed to a different sprint, it must be uncommitted first. When the commit completes, notify the sprint from which it was uncommitted and the sprint to which it is now committed. What do you think of that scenario? It's pretty good, we can actually start writing tests and start implementing our model code, to prove out that this scenario actually works. How does that happen? Well, we could use one of two different approaches. For example, we could use specification by example, what's also referred to as, behavior-driven development or BDD. Here's an example, we have a Given-When-Then scenario, where we break a scenario, such as the product owner commits a backlog item to a sprint, into three different sections. The given, which is, where our model is in the point in time, and how its data currently is set, and when a specific business operation occurs, then we can assert that certain conditions are met, so let's see what those are. Again, our scenario is labeled, the product owner commits a backlog item to a sprint. Given a backlog item that is scheduled for release, that was one of our requirements, our constraints, and the product owner of the backlog item, because we need a product owner in order to commit the backlog item to the sprint, and a sprint for commitment, and also a quorum of team approval for commitment, so those are our givens. If we have those objects set up for us when the product owner commits a backlog item to the sprint, so that's the actual primary operation that we're interested in, then, the backlog item is committed to the sprint, so we can assert that the backlog item itself knows that it is now committed to a sprint after that operation, and we have a backlog item committed event that has been created. Now, some teams use this approach and actually implement this scenario with software behind the scenes, they create what's called an acceptance test, they take the criteria for the acceptance test, and they implement it as a BDD test, implementing also the model that helps us achieve this test, and then execute the scenario as an acceptance test off of this scenario. It can be pretty tempting to try to keep up with this level of software accuracy and acceptance testing, but it can also add some overhead, I'm not going to vote for or against this approach, just be aware that there is a learning curve involved in this, and you probably also need some expert advice before you go down this path, but understand that you can still use the Given-When-Then approach without implementing the backing tests, just to allow for good communication and collaboration on your team. Another approach that can be used is to develop a unit test specification. Notice that I've set up this test, in C Sharp in this case, that is named ShouldCommitBacklogItemToSprint, and then notice also that in the code, I've written three different comments, Given, When and Then, so ultimately, this unit base test follows much the same approach as the scenario that we just previously looked at, but we're using a unit test approach, rather than implementing a specification test behind the scenario that was written. In this case, we have, as given, a BacklogItemScheduledForRelease, we have a ProductOwner, we have a SprintForCommitment, and we have a QuorumOfTeamApproval, so this is the given, these are, in essence, the fixtures to our unit test. And then, we have our when clause, which says when a backlog item is committed to a sprint with a product owner and a quorum of team commitment, or team approval, then we can assert that the backlog item is committed, that that is a true statement, and, we can ask the backlog item for the events that were created on it when that operation occurred, the CommitTo, and we're going to expect a BacklogItemCommitted domain event, and we can assert that that BacklogItemCommitted domain event is not null. So now we've accomplished much the same thing that could be accomplished with the previous BDD, or specification by example scenario, but it can be much easier, much quicker, to implement this as a unit test.

- By now, you're probably wondering, "What does a bounded context actually look like internally? "Is it just the domain model? "What is the architecture of a bounded context? "What are some of the architectures "or architectural patterns that can be used "for a bounded context and within a bounded context?" Well, you have some options here. This architecture diagram illustrates a ports and adapters architecture. This has also been called the hexagonal architecture, some call it the onion architecture, maybe you even have another name for this architecture. But the strength of this architecture is that we have, at the center or the middle of the architecture, a domain model. This is at the heart of the software. Around the domain model, we typically have some sort of application services. The application services manage our transactions for us, perhaps they manage security as well, but they also are task managers for the use cases that the software needs to perform. Ultimately, it's the application services that invoke methods on the domain model to carry out the operations of our scenarios that we've just discussed. On the outside of the architecture, the dark blue part, are the adapters for the various ports. Now, you can think of these adapters in a few different ways. I like to think of them as ports that are incoming request operations from the outside world. At the top, toward the left of this diagram, we see a globe. This represents the world wide web or browsers. So, here we have a browser that is making requests of our bounded context and those requests are being adapted by a port adapter specifically made for browsers, and that port adapter is adapting the requests to the internal application services or API so that those application services can delegate to the domain model to have the actual operations executed. Below the representation for browsers is a mobile phone. Perhaps we have a mobile phone that's making requests to our architecture. We also have the cloud. Maybe this is integration from other bounded contexts. And we have a messaging port with a lightning bolt. This messaging port is accepting incoming messages that, in turn, like all the other adapters there on the left-hand side, will be adapted to the internal model, which is represented by the domain model and then the surrounding application services or API. So, all of these internal requests are focused on adapting to the internal API, the API then delegates to the domain model. On the right-hand side of the diagram, you see output ports. These are opposite of the input ports that we were just talking about. The output ports can be, for example, repositories that talk to a relational database, or perhaps to a document database, or to an in-memory grid. We have a lot of different options there. We also have an outgoing adapter that goes to the lightning bolt or the messaging mechanism. So, we're accepting messages in and we're producing messages or sending messages through our output port as well. So, this architecture well-represents a typical architecture that can be used with domain-driven design. Here's another view of that architecture tipped on its side. We have input adapters and output adapters at the outside of the architecture. Internally, we have our application services and our application services call the domain model. Within our input adapters we may have security, we may have our user interface and we may have RESTful representations. Also, in our application services, have security, transactions, task coordination, use case controllers, and so forth. Within our domain model, which we've been talking about, we have our entities, we have our business logic, we have domain events. And in our output adapters, we may have repositories, documents, cache, and messaging. So, this gives you two different views of the same architecture. Other architectures or architectural patterns that can be used with domain-driven design are numerous. For example, in lesson six, we're going to talk about an event-driven architecture and event sourcing. This will teach you how to use domain events in an architectural way to send notifications of facts that have occurred in your domain model to other bounded contexts. You'll also have the ability to use command query responsibility segregation or CQRS. We won't talk about that much in this course but there is other literature that you can derive information from about how to implement CQRS. Reactive and the actor model can also be used. This is an area that I like to specialize in, reactive software development with the actor model. And this is a very clear and very powerful approach to implementing both an event-driven architecture and CQRS within our bounded context by the use of concurrency with actors. And there's also REST or representational state transfer, which we can use in a DDD environment, and microservices as well as service-oriented architecture, whichever way you appreciate that discussion being defined. So, you can use DDD with microservices, you can use DDD with service-oriented architecture.

- [Instructor] In summary you learned the pitfalls of putting too much into one model and creating a big ball of mud. The application of DDD strategic design. You also learned the use of bounded context and the ubiquitous language. And you learned how to challenge your existing model and unify according to your bounded context and ubiquitous language. You learned how to develop a ubiquitous language using domain model scenarios. And you learned how to use the architectural components, whether they're architectural patterns, or architectures, to develop your bounded context. Most importantly I think that you learned that DDD is not too difficult to put into practice yourself.

