---
layout: post
title: 领域驱动设计DDD入门4：上下文映射
categories: [dev]
tags: [ddd]
---

欢迎来到第四课：战略工具之上下文映射。
本课重点介绍上下文映射以及各种团队关系和集成技术，这些技术可用于管理多个有界上下文如何和谐地工作以形成整个系统解决方案。
首先，我将介绍有限上下文之间的上下文映射。这导致对各种上下文映射、团队关系和集成技术的检查，包括伙伴关系、共享内核、客户供应商、遵从者、反腐层、开放主机服务、发布语言、大泥球等。然后我们看一下如何充分利用上下文映射，我们会将上下文映射与SOAP和RPC一起使用，RESTful HTTP和消息传递。最后，我给出一个使用消息传递和REST的使用上下文映射的示例。

思考一个问题：我们的核心域和其他子域是如何集成的，它们关系如何？比如我们的敏捷项目管理软件和协作上下文集成在一起，这样敏捷软件就有了论坛和日历功能。那么这两个子域之间是啥样的呢？

我们要研究的第一个关系是伙伴关系。当两个团队在两个不同的边界上下文中工作，而他们有共同的目标并且互相支持时构成伙伴关系。
有伙伴关系的两个组织有非常重的关系，因为他们必须相互协调他们的上线，必须同时发布，因为他们相互支持。两者之间没有上游下游关系，他们的模型在相当长的一段时间内保持同步。因此需要大量的协调、大量的规划。这两个团队必须认真合作，以确保一切顺利进行，相互支持。

共享内核是两个或多个团队拥有非常相似的软件模型。因此，他们将开发出单个要使用的共享模型部分。这是一个相对不正常的情况，因为要确保两个团队都能从这个小核心模型中受益，需要进行大量规划以及大量的协调和集成测试。共享内核不太可能会经常使用，因为这要求团队共享大量信息，并就模型如何协同工作达成共识。不太可能在两个不同的团队之间形成那种沟通和协调的水平，因为他们往往不会进行协作或有效地进行沟通。

客户供应商关系是两个团队之间存在确定的上游下游关系。比如团队1位于上游，团队2位于下游。那上游团队1的模型更改将对下游团队2产生影响。所以更改的时候必须通过协商来协。团队1和团队2需要一起进行协商，团队2会要求团队1正在开发中的某些功能必须满足这种协调，以便团队2可以获取他们需要的功能。如果没有达成，那么团队2将无法在他们需要的时间范围内获得所需的东西，因此对团队2可能产生非常负面的影响。

遵从关系是指存在明确的上游下游关系的情况，其中团队1具有直接影响下游团队2模型的上游模型。团队2基本上只是奴隶般的消耗团队1的模型并遵守该模型。可能因为是一个复杂的模型或一个大型模型，团队2没有时间或资源进行修改。因此，他们像使用自己的模型一样简单地消费它。

在防腐层中，有两个具有单独模型的团队，下游团队不想受到上游模型的不必要影响就使用防腐层。可以看到这是遵从关系模式的反面。
上游团队拥有自己的模型，下游团队将使用该模型，但会将上游模型的数据和其他结构转换为下游域模型或有界上下文中的自身结构和数据，所以不会受上游团队的影响。

开放主机服务是一个文档齐全、定义明确、使用方便且美观的用于消费的模型，是上游团队提供的良好API。可能是restful的，也可能是消息api，也可能是RPC api。无论哪种都有完整的文档，可以方便的集成。下游团队直接使用开放主机服务，可以直接使用其模型或者可以方便的转换。

发布语言是上游团队使用的一种用来生成定义明确、文档齐全的数据交换格式的语言，生成的数据格式可以使小组2非常舒适、方便地使用。开放主机服务向下游团队提供发布语言是很常见的。因此，使用不同模型的数据和结构也非常方便，并且团队2可以轻松地将其转换为标准格式。

Separate ways describes the kind of integration that could take place between Team 1 and Team 2. For whatever reason, perhaps expense, perhaps lack of convenience, perhaps it's because of the low benefit of consuming Team 1's model, Team 2 decides to go separate ways. And create a one-off solution within its own model to the solution that they need and could've consumed from Team 1. But they simplify things and simply go a separate direction from how they could've used the integration with Team 1.

We've already talked about a big ball of mud. Of course, you want to steer away from developing a big ball of mud as much as possible by using the DDD strategic tools. However, you will likely have to integrate with a big ball of mud at some point. Now, another warning about the big ball of mud and developing a big ball of mud is this. When you make changes in one part of the model, it will very likely have a negative impact on another part of the model. Where you have changes that ripple and you end up with whackable issues is where one change has a negative impact on the data or the model in another area, and you try to stomp out that situation, and when you change that, then this changes ripples to another area. The big ball of mud is actually a very negative situation to be in as far as a domain model. So you should steer against it. If you do have to integrate with a big ball of mud, try to use an anti-corruption layer between your downstream bound of context, which is no doubt a clean core domain, and the upstream big ball of mud. This will allow you to consume the big ball of mud on your terms and make its data and structure adhere to your data and structure in your model in the downstream.

How will you actually use context mapping for integration between bounded contexts? While we're going to discuss now three different integration styles and how these can be used with context mapping, we're going to discuss RPC, or remote procedure calls, we're going to discuss RESTful integrations, and we're going to discuss messaging.

First of all, let's discuss RPC with SOAP. This is where we have a Service Bounded Context and a Client Bounded Context; The Client Bounded Context must look up a service in a service registry and that service will be used in the Service Bounded Context and consumed by the client; the disadvantage with using RPC is that RPC can fail, because of network situations, perhaps in network partition or other situations such as bandwidth, some sort of interruption in network connections; they're all kinds of things that can happen with RPC and so, the disadvantages that a client who depends on an RPC integration with the Service Bounded Context may be unable to complete its integration in real time, which can cause failure. But, when RPC works and RPC mostly works, it can be a very desirable and convenient way to implement an integration. The Service Bounded Context will likely benefit from being designed as an Open Host Service with a published language and with downstream consuming Bounded Context can use an empty corruption layer in order to translate and use the upstream model only on its own terms, such that the Client Bounded Context will have its own unique model, its own unique data instructure and it does so by translating from the upstream Open Host Service and published language into its own unique model composition.

RESTful HTTP is much like RPC in that a client bounded context must communicate with a service bounded context through a network connection. The common verbs used in a restful integration are post, get, put and delete. These are provided by the service bounded context. And the client bounded context uses these verbs to accomplish certain goals within the integration of the service bounded context. These are are the RESTful HTTP requests. Again, when integrating a service bounded context with a client bounded context you're going to exchange data quite likely using a document format of some kind. These are the RESTful representations that are exchanged between the two bounded contexts. Typically you will want to again create an open host service with a published language on the service bounded context. The published language is actually the representations that are exchanged between the two contexts. The client bounded context would also likely benefit if it had an anti-corruption layer that translates the representations that are provided by the service bounded context into it's own local model. Just be aware that with this sort of integration, you will also likely face at some time problems with the network in the same way that hinders this integration when using RPC, rest integrations will have to be handled in much the same way with potential network failure. And that's what we see here where there is a disconnect between the client bounded context and the service bounded context. When designing resources for your service bounded context your published language, you should design the resources according to the use cases that your client wants to consume. If you have multiple clients, you'll want them each to have the opportunity to consume your resources on their terms. This will prevent the service bounded context from forcing each client to have a conformist relationship with the service bounded context. You would force your consumers into a conformist relationship if you designed your resources according to your own internal domain model. Don't do that. You'll make your clients much happier if you listen to their needs and allow them to consume your resources according to their own use case requirements.

As you've seen with RPC and RESTful integrations, the network can cause problems for this kind of integration. We're going to now look at a more robust form of integration, that of using messaging. Messaging with DDD oftentimes uses domain events for the integration. This is where an aggregate and domain events are published by aggregates and consumed by other bounded contexts. This is through a messaging mechanism. And there are a lot of different options for using messaging mechanisms. So the main pattern is where an aggregate will publish a domain event, and that aggregate, in publishing the domain event, makes the domain event available for another bounded context and the other bounded context, the subscribing bounded context, will get the domain event from the publishing bounded context, and this domain event will likely have an impact on another aggregate in the subscribing bounded context. Sometimes, you must provide a command to the service bounded context in order to get it to do something to cause a domain event to occur so that the domain event can have an impact on the consuming, or client bounded, context. When you use domain events with a messaging mechanism, you must support at-least-once delivery and your receiver, or subscribing bounded context, must be an idempotent receiver. What I mean by that is the messaging mechanism that you choose must support at-least-once delivery. That means that the message will be delivered at least once. Because the message can be delivered at least once, the subscribing bounded context must be idempotent, or have the ability to, in essence, de-duplicate or consume without negative consequence, a redelivered domain event message. Here's what I mean by that. If a messaging mechanism delivers a message, it may be that before the acknowledgement of the receiver that it has received the message to the messaging mechanism, can cause the same message to be delivered more than once. Here you see the message being delivered twice and in this case only one acknowledgement is provided. Therefore, because the messaging mechanism can cause the message to be delivered more than once, the receiver must be an idempotent receiver, like you see here. Let's say that the message that is delivered by the messaging mechanism is the message to open some sort of resource. If that message is delivered twice, or three times, or more, the receiver must be able to react responsibly to that multiple reception and cause the resource to only actually be opened once, not multiple times. This can be accomplished by de-duplicating the message within the receiver. It can also be caused, or be handled by some form of keeping the state of the resource, such as the status, already being open. That will prevent the open of the resource multiple times.

Let's go through an example of integrating using messaging what we're going to do is go back to our example of policy within three different bounded contexts. We have our insurance, industry example, we have an underwriting context, a claims context and an inspections context. We're going to look at how to integrate these bounded contexts by means of messaging with domain events. Let's say that a policy first becomes created and alive within the underwriting context. Underwriting is generally where the insurance company will make an agreement with a customer to insure them and the policy at that point becomes existing. Now, insurance terms it's probably the case that this policy will be deemed issued so the domain event that's going to be published by the underwriting context is the policy issued domain event. When the policy issued domain event is published by the underwriting context it can now be consumed by the claims context and the inspections context. When this happens, it can cause the creation of policies in the other two bounded contexts. In other words, the claims context will create a policy of its own type within its own bounded context in reaction to the policy issued domain event. And the policy issued domain event will also cause the creation of a policy in the inspections context according to the terms of inspections and therefore we now have three separate policies. One that was originally created in the underwriting context and the other two that were created in reaction to the policy issued domain event. In the underwriting context, we have created our policy and created the policy issued domain event which causes in the subscribing bounded context a policy to be created. Now, how much data does the policy issued domain event hold? It should be somewhat limited, we don't want to necessarily publish a domain event that has all of the state of the policy from the underwriting context. It should just have enough state to convey the fact that the policy has been issued and allow that policy to be reacted to in other bounded contexts. But it could be that one of our subscribing bounded contexts needs more data from the underwriting context. What can we do? Well we can actually allow our subscribing context to query back on the underwriting context using the policy ID of the policy that was issued in the underwriting context to allow it to query the data that it specifically needs in the subscribing bounded context. Notice in the subscribing bounded context that policy in that context holds the original policy ID from the underwriting context under the name of issued policy ID. This refers back to the exact identity of the policy entity in the underwriting context which allows us to perform a specific kind of query. The underwriting context can then implement an open host service with a published language and the subscribing bounded context can use a restful GET request to get more policy data from the underwriting context. As you can see there it does a GET verb in a restful way slash policy slash issued policy ID. And from this it receives data in the form of a published language, thus, the underwriting context publishes its policy issued domain event with a policy ID and that policy ID can be used to consume other information from the underwriting context. What about the example that we had before with the agile project management context and its surrounding, supporting and generic sub-domains, don't worry, we'll return to that example next.

[Instructor] In summary, in this lesson you learned about the various kinds of context mapping relationships such as the partner relationship, the consumer-supplier relationship, and anticorruption layer. You also learned how to use context mapping and integration with RPC, with RESTful HTTP, and with messaging. You learned how domain events work and how to use them in a messaging environment, and you learned the foundation on which you can build your context mapping experience.

