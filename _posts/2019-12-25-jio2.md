---
layout: post
title: Java的IO系统 - 字节流类
categories: [dev]
tags: [java]
---

Java的IO系统针对输入和输出分别有两个基类：字节输入流InputStream、字符输入流Reader，字节输出流OutputStrea、字符输出流Writer。在操作字符或字符串时应该使用字符流，在操作字节或其他二进制格式时，应使用字节流。这里先介绍字节流的常用实现类。

# InputStream类
InputStream是字节输入的抽象父类，实现了Closeable接口，可能会抛出IOException异常。主要方法如下(按字母序排列)：

> IO异常不是运行时异常，所以要提前准备好处理方案

| 方法                                               | 描述                                                                                                                       |
| -------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| int available( )                                   | 返回当前可读取的输入字节数                                                                                                 |
| void close( )                                      | 关闭输入源。如果试图继续进行读取，会产生IOException异常                                                                    |
| void mark(int numBytes).                           | 在输入流的当前位置放置标记，该标记在读入numBytes个字节之前一直都有效                                                       |
| boolean markSupported( )                           | 如果调用流支持mark或reset方法，就返回true                                                                                  |
| int read( )                                        | 返回代表下一个可用字节的整数。当到达文件末尾时，返回-1                                                                     |
| int read(byte buffer[ ])                           | 尝试读取buffer.length个字节到buffer中,并返回实际成功读取的字节数。 如果到达文件末尾，就返回-1                              |
| int read(byte buffer[ ], int offset, int numBytes) | 尝试读取numBytes个字节到buffer中,从buffer[offset]开始保存读取的字节。该方法返回成功读取的字节数;如果到达文件末尾，就返回-1 |
| void reset( )                                      | 将输入指针重置为前面设置的标记                                                                                             |
| long skip(long numBytes)                           | 忽略(即跳过)numBytes个字节的输入，返回实际忽略的字节数                                                                     |

其中mark和reset方法不一定需要具体实现，它们是同步方法，需要用到的场景实现即可，并将markSupported置为true。

# OutputStream
字节输出流的抽象父类实现了Closeable接口和Flushable接口。主要有以下方法，基本都无返回值：

| 方法                                              | 描述                                                                                                         |
| ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| void close( )                                     | 关闭输出流。如果试图继续向流中写入内容，将产生IOException异常                                                |
| void flush( )                                     | 结束输出状态，从而清空所有缓冲区，即冲刷输出缓冲区                                                           |
| void write(int b)                                 | 向输出流中写入单个字节。注意参数是int类型，从而允许使用表达式调用write方法，而不用将表达式强制转换回byte类型 |
| void write(byte buffer[])                         | 向输出流中写入一个完整的字节数组                                                                             |
| void write(byte buffer[],int offset,int numBytes) | 将buffer数组中从buffer[offset]开始的numBytes个字节写入输出流中                                               |

---

---

两个基类中方法都不多，尽量仔细看一遍有了印象都。下面说一下他们的实现类。

# FileInputStream
FileInputStream类专门用于从文件读取字节，它的构造函数要么接受一个字符串的文件路径，要么接受一个File格式的文件对象，文件找不到都会抛出FileNotFoundException异常。建议使用第二个构造方法，可以在创建流之前对文件进行校验等工作。文件流没有重写mark方法，调用reset会报异常。

下面是简单的演示代码（这个类也不复杂）：
```java
int size;
try (FileInputStream f = new FileInputStream("/Users/sheldon/IdeaProjects/QLExpress/README.md")) {
    System.out.println("文件总字节数" + (size = f.available()));
    int n = size / 400;
    System.out.println("分400份，头" + n + "个字节：");
    for (int i = 0; i < n; i++) {
        System.out.print((char) f.read());
    }
    System.out.println("\n剩余字节数： " + f.available());
    System.out.println("接下来" + n + "个字符：");
    byte b[] = new byte[n];
    if (f.read(b) != n) {
        System.err.println("不足" + n + "个字符。");
    }
    System.out.println(new String(b, 0, n));
    System.out.println("\n剩余字节：" + (size = f.available()));
    System.out.println("跳过总的一半");
    f.skip(size / 2);
    System.out.println("剩余字节 " + f.available());
} catch (IOException e) {
    e.printStackTrace();
} 
```
输出如下：
```
文件总字节数21885
分400份，头 54个字节：
# QLExpressåºæ¬è¯­æ³

[![Join the chat at https://g
剩余字节数： 21831
接下来54个字符：
itter.im/QLExpress/Lobby](https://badges.gitter.im/QLE

剩余字节：21777
跳过总的一半
剩余字节 10889
```

> 注意文件里的中文是乱码了，原因很简单，因为一个汉字至少要占用两个字节，一个一个的转码肯定不认识了。后面我们再说中文的处理。

# FileOutputStream
这个类用于将字节流写入文件中。有两种构造方法，一种是指定文件的位置（文件可以不存在），第二种会多指定一个参数标明是追加还是覆盖。如果文件打不开或者是一个目录或其他原因没法创建输出流目标，就会报FileNotFoundException异常。

下面是一个例子：我们将一段文本写入文件1，将文本的最后10个字节写入文件2
```java
try (FileOutputStream fos1 = new FileOutputStream("t1.txt");
    FileOutputStream fos2 = new FileOutputStream("t2.txt");) {
    String s = "A distributed transaction solution with high performance and ease of use for microservices architecture.\n" +
            "Distributed Transaction Problem in Microservices\n" +
            "Let's imagine a traditional monolithic application. Its business is built up with 3 modules. They use a single local data source.\n" +
            "Naturally, data consistency will be guaranteed by the local transaction.";
    byte[] bytes = s.getBytes();
    int l = bytes.length;
    fos1.write(bytes);
    fos2.write(bytes, l - 10, 10);
}
```

> 如果截取的过程不幸将汉字截断也会乱码，可以自己试一下（比如在字符串末尾增加几个汉字）

# ByteArrayInputStream
该类是将字节数组做为流输入，一般来源是字符串。构造函数接收字符数组，也可以额外接受截取的位置和长度。该类重写了mark和reset方法，可以通过例子看一下：

```java
try (ByteArrayInputStream is = new ByteArrayInputStream("abc".getBytes())) {
    boolean again = false; // 记录是否第二次
    while (true) {
        int read = is.read();
        if (read == -1) {
            if (!again) {
                is.reset();
                again = !again;
                read = is.read();
            } else
                break;
        }
        System.out.print(read);
        System.out.print((char) read);

        if (read == 98) {
            is.mark(0);// 传入的参数无效 可以随便写
        }
    }
}
```

输出：97a98b99c99c

# ByteArrayOutputStream

